[{"title":"android矩阵Matrix","date":"2017-03-29T09:43:41.000Z","path":"2017/03/29/android矩阵Matrix/","text":"\\begin{bmatrix}scale_x&amp; ske_x &amp; trans_x \\skew_y &amp; scale_y &amp; trans_y \\perep_0 &amp; persp_1 &amp; persp_2\\end{bmatrix}","tags":[{"name":"Android","slug":"Android","permalink":"//dongqing123.cn/tags/Android/"},{"name":"Matrix","slug":"Matrix","permalink":"//dongqing123.cn/tags/Matrix/"}]},{"title":"RecyclerView拖拽排序与滑动删除","date":"2017-03-29T03:23:26.000Z","path":"2017/03/29/ItemTouchHelper实现RecyclerView拖拽与滑动删除/","text":"RecyclerView 作为ListView、GridView的替代品，从它诞生开始就如火如荼，很多基于其改造的刷新、header控件应运而生，今天我们的主角是拖拽与删除效果，很多关于ListView拖拽、侧滑菜单的控件可能并不能移植到RecyclerView上，但作为继承物怎么能不支持拖拽与侧滑呢？ItemTouchHelper便是一个用于处理RecyclerView拖拽与滑动删除的强大工具，可以轻而易举的支持几乎所有LayoutManager，并且支持item的动画等等。ItemTouchHelper在使用上也是非常的简单的，只需要新建ItemTouchHelper实例，然后attachToRecyclerView就可以了，是不是相当容易。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class TouchCallBack extends ItemTouchHelper.Callback &#123; ItemTouchHelperCallback callback; void setItemTouchHelperCallback(ItemTouchHelperCallback callback) &#123; this.callback = callback; &#125; @Override public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123; int dragFlag, swipeFlag = 0; if (recyclerView.getLayoutManager() instanceof GridLayoutManager) &#123; dragFlag = ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT; &#125; else &#123; dragFlag = ItemTouchHelper.UP | ItemTouchHelper.DOWN; swipeFlag = ItemTouchHelper.START | ItemTouchHelper.END; &#125; return makeMovementFlags(dragFlag, swipeFlag); &#125; @Override public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) &#123; int fromPosition = viewHolder.getAdapterPosition(); int toPosition = target.getAdapterPosition(); if (callback != null) &#123; callback.onItemMove(fromPosition, toPosition); &#125; return true; &#125; @Override public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) &#123; if (callback != null) &#123; callback.onItemDismiss(viewHolder.getAdapterPosition()); &#125; &#125; @Override public void onSelectedChanged(RecyclerView.ViewHolder viewHolder, int actionState) &#123; if (actionState != ItemTouchHelper.ACTION_STATE_IDLE) &#123; viewHolder.itemView.setBackgroundColor(Color.LTGRAY); &#125; super.onSelectedChanged(viewHolder, actionState); &#125; @Override public void clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123; super.clearView(recyclerView, viewHolder); viewHolder.itemView.setBackgroundColor(Color.TRANSPARENT); &#125; public interface ItemTouchHelperCallback &#123; void onItemMove(int fromPosition, int toPosition); void onItemDismiss(int position); &#125;&#125; ItemTouchHelperCallback是我们自定义用于拖拽、删除的回调接口 getMovementFlags指定支持拖拽、滑动的方向，使用helperItemTouchHelper.makeMovementFlags(int, int)来构造返回的flag onMove是拖拽的方法 onSwiped是删除的方法 isLongPressDragEnabled是否支持拖拽，默认true isItemViewSwipeEnabled是否支持滑动删除，默认true onSelectedChanged选中item时的方法，这里我们以示区别改变了背景 clearView完成时的方法，这里我们把背景改成了透明 然后只需要简单的如下操作便可以了12345678910111213141516TouchCallBack touchCallBack = new TouchCallBack();touchCallBack.setItemTouchHelperCallback(new TouchCallBack.ItemTouchHelperCallback() &#123; @Override public void onItemMove(int fromPosition, int toPosition) &#123; Collections.swap(data, fromPosition, toPosition); adapter.notifyItemMoved(fromPosition, toPosition); &#125; @Override public void onItemDismiss(int position) &#123; data.remove(position); adapter.notifyItemRemoved(position); &#125;&#125;);ItemTouchHelper touchHelper = new ItemTouchHelper(touchCallBack);touchHelper.attachToRecyclerView(recyclerView); 效果如下 如果我们仅仅只是需要拖拽或者滑动删除大可不必继承ItemTouchHelper.Callback而继承ItemTouchHelper.SimpleCallback实现构造、onMove与onSwiped即可 比如我们有这个的需求并不是所有的item都支持拖拽与删除，那我们需要做一些改变，将 isLongPressDragEnabled，isItemViewSwipeEnabled返回false。然后我们需要监听item的长按事件，再判断是否有拖拽、删除功能，最后手动调用 touchHelper.startDrag(ViewHolder viewHolder)和touchHelper.startSwipe(ViewHolder viewHolder)实现效果。这里RecyclerView的事件使用liaoinstan的介绍的OnItemTouchListener事件完成。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public abstract class OnRecyclerTouchListener implements RecyclerView.OnItemTouchListener &#123; private GestureDetectorCompat mGestureDetector; private RecyclerView recyclerView; public OnRecyclerTouchListener(RecyclerView recyclerView) &#123; this.recyclerView = recyclerView; mGestureDetector = new GestureDetectorCompat(recyclerView.getContext(), new ItemTouchHelperGestureListener()); &#125; @Override public boolean onInterceptTouchEvent(RecyclerView rv, MotionEvent e) &#123; mGestureDetector.onTouchEvent(e); return false; &#125; @Override public void onTouchEvent(RecyclerView rv, MotionEvent e) &#123; mGestureDetector.onTouchEvent(e); &#125; @Override public void onRequestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123; &#125; private class ItemTouchHelperGestureListener extends GestureDetector.SimpleOnGestureListener &#123; @Override public boolean onSingleTapUp(MotionEvent e) &#123; View child = recyclerView.findChildViewUnder(e.getX(), e.getY()); if (child != null) &#123; RecyclerView.ViewHolder vh = recyclerView.getChildViewHolder(child); onItemClick(vh); &#125; return true; &#125; @Override public void onLongPress(MotionEvent e) &#123; View child = recyclerView.findChildViewUnder(e.getX(), e.getY()); if (child != null) &#123; RecyclerView.ViewHolder vh = recyclerView.getChildViewHolder(child); onItemLongClick(vh); &#125; &#125; @Override public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123; View child = recyclerView.findChildViewUnder(e1.getX(), e1.getY()); if (Math.abs(distanceX) &gt; 0 &amp;&amp; distanceY == 0) &#123; if (child != null) &#123; RecyclerView.ViewHolder vh = recyclerView.getChildViewHolder(child); onSideSlip(vh); &#125; &#125; return super.onScroll(e1, e2, distanceX, distanceY); &#125; &#125; public abstract void onItemClick(RecyclerView.ViewHolder vh); public abstract void onItemLongClick(RecyclerView.ViewHolder vh); public abstract void onSideSlip(RecyclerView.ViewHolder vh);&#125; 我们添加了三个抽象方法，用单击、长按、侧滑的回调，然后通过监听手势动作，调用相应的方法，然后我们把下面两个方法返回FALSE12345678@Overridepublic boolean isLongPressDragEnabled() &#123; return false;&#125;@Overridepublic boolean isItemViewSwipeEnabled() &#123; return false;&#125; 最后给RecyclerView添加事件12345678910111213141516recyclerView.addOnItemTouchListener(new OnRecyclerTouchListener(recyclerView) &#123; @Override public void onItemClick(RecyclerView.ViewHolder vh) &#123; &#125; @Override public void onItemLongClick(RecyclerView.ViewHolder vh) &#123; touchHelper.startDrag(vh); &#125; @Override public void onSideSlip(RecyclerView.ViewHolder vh) &#123; touchHelper.startSwipe(vh); &#125;&#125;); 这样我们可以通过条件判断手动调用拖拽与侧滑的方（这里直接调用了，我们可以根据实际情况添加判断）。到这里ItemTouchHelper关于拖拽与侧滑的操作基本完成，当然我们还可以覆盖着两个方法123456789@Overridepublic void onChildDraw(Canvas c, RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, float dX, float dY, int actionState, boolean isCurrentlyActive) &#123; super.onChildDraw(c, recyclerView, viewHolder, dX, dY, actionState, isCurrentlyActive);&#125;@Overridepublic void onChildDrawOver(Canvas c, RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, float dX, float dY, int actionState, boolean isCurrentlyActive) &#123; super.onChildDrawOver(c, recyclerView, viewHolder, dX, dY, actionState, isCurrentlyActive);&#125; 添加一些交互的动画，让操作更人性化，例如侧滑删除时改变item的透明度、或者添加滑动删除的提示，拖拽时添加长按下去的动画等等。更多操作请查看https://github.com/iPaulPro/Android-ItemTouchHelper-Demo","tags":[{"name":"RecyclerView","slug":"RecyclerView","permalink":"//dongqing123.cn/tags/RecyclerView/"},{"name":"ItemTouchHelper","slug":"ItemTouchHelper","permalink":"//dongqing123.cn/tags/ItemTouchHelper/"},{"name":"拖拽排序","slug":"拖拽排序","permalink":"//dongqing123.cn/tags/拖拽排序/"},{"name":"滑动删除","slug":"滑动删除","permalink":"//dongqing123.cn/tags/滑动删除/"}]},{"title":"android动画（三）","date":"2017-03-27T08:17:01.000Z","path":"2017/03/27/android动画-三/","text":"上一篇android动画（二）我们介绍了属性动画的基本操作，介绍了ObjectAnimator、ValueAnimator、AnimatorSet等动画的操作的使用，顺便介绍了对于view的ViewProperty动画。 TypeEvaluator上一篇我们遗漏了ofObject，主要是涉及到TypeEvaluator的使用，该类主要是如何从初始值过渡到结束值。我们知道ofInt、ofFloat内部就使用的IntEvaluator和FloatEvaluator，源码如下123456public class IntEvaluator implements TypeEvaluator&lt;Integer&gt; &#123; public Integer evaluate(float fraction, Integer startValue, Integer endValue) &#123; int startInt = startValue; return (int)(startInt + fraction * (endValue - startInt)); &#125;&#125; 123456public class FloatEvaluator implements TypeEvaluator&lt;Number&gt; &#123; public Float evaluate(float fraction, Number startValue, Number endValue) &#123; float startFloat = startValue.floatValue(); return startFloat + fraction * (endValue.floatValue() - startFloat); &#125;&#125; 源码很简单，第一个参数fraction表示动画的进度，后面两个一个是初始值，一个是结束值，逻辑代码比较简单就是初始值加上进度乘以结束值减初始值。那么我们在使用ofObject时需要自己实现一个TypeEvaluator。下面我们举个例子说明，比如我们需要改变textview字体的颜色123456789101112131415161718class ColorEvaluator implements TypeEvaluator&lt;Integer&gt; &#123; @Override public Integer evaluate(float fraction, Integer startValue, Integer endValue) &#123; int startA = (startValue &gt;&gt; 24) &amp; 0xfff;//透明度 int startR = (startValue &gt;&gt; 18) &amp; 0xfff;//Red int startG = (startValue &gt;&gt; 8) &amp; 0xfff;//Green int startB = startValue &amp; 0xfff;//Blue int endA = (endValue &gt;&gt; 24) &amp; 0xfff;//透明度 int endR = (endValue &gt;&gt; 18) &amp; 0xfff;//Red int endG = (endValue &gt;&gt; 8) &amp; 0xfff;//Green int endB = endValue &amp; 0xfff;//Blue return (startA + (int) (fraction * (endA - startA)) &lt;&lt; 24) | (startR + (int) (fraction * (endR - startR)) &lt;&lt; 16) | (startG + (int) (fraction * (endG - startG)) &lt;&lt; 8) | (startB + (int) (fraction * (endB - startB))); &#125;&#125; 然后我们便可以使用ofObject设置动画了123456789ValueAnimator animator=ValueAnimator.ofObject(new ColorEvaluator(), Color.RED,Color.BLUE);animator.setDuration(2000);animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; textView.setTextColor((Integer) valueAnimator.getAnimatedValue()); &#125;&#125;);animator.start(); 当然在api版本21中我们可以使用ofArgb()123456789ValueAnimator animator=ValueAnimator.ofArgb(Color.RED,Color.BLUE);animator.setDuration(2000);animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; textView.setTextColor((int) valueAnimator.getAnimatedValue()); &#125;&#125;);animator.start(); 或者123ObjectAnimator animator=ObjectAnimator.ofArgb(textView,\"textColor\",Color.RED,Color.BLUE);animator.setDuration(2000);animator.start(); 我们知道ofArgb内部使用的是ArgbEvaluator，发现其内部源码就是我们写的ColorEvaluator（当然这里是我拷贝的人家的代码）。因此我们便实现通过TypeEvaluator实现一些复杂的动画，详情可以参考郭霖大神相关的文章。 TimeInterpolate插值器我们在android动画（一）补间动画中有简单的介绍系统的自带插值器，它主要用于控制动画的变化速率类似于物理上加速度，系统默认插值器是AccelerateDecelerateInterpolator，是中间较快，两端较慢，也就是先加速或减速。查看源码我们发现AccelerateDecelerateInterpolator继承BaseInterpolator，BaseInterpolator则是实现Interpolator，Interpolator继承了TimeInterpolator。123public interface TimeInterpolator &#123; float getInterpolation(float input);&#125; 接口很简单只有一个getInterpolation，参数是float返回一个float，input这个值随动画的运行不断变化，不过它的范围是0-1，也就是初值0，终值1，匀速递增。在TypeEvaluator曾有个表示动画的进度fraction参数，其实它就是这里的返回值。android自带了一个LinearInterpolator，我们查看他的源码发现1234567public class LinearInterpolator extends BaseInterpolator ...&#123; ... public float getInterpolation(float input) &#123; return input; &#125; ...&#125; 它没有做任何的处理直接返回了input，也就是input与fraction值是相同的。因此动画便做匀速运动。对于AccelerateDecelerateInterpolator则返回的是一个余弦函数123public float getInterpolation(float input) &#123; return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f;&#125; 对三角函数有一定了解的就会知道是cos函数在[π，2π]的一段，大家观看函数图像就明白了 。AccelerateInterpolator是指数函数1234567public float getInterpolation(float input) &#123; if (mFactor == 1.0f) &#123; return input * input; &#125; else &#123; return (float)Math.pow(input, mDoubleFactor); &#125;&#125; 当然我们也可以同理分析其他的插值器，如果系统自带的满足不了我们的要求，我们可以自定义插值器，重写getInterpolation便可以了。 最后本期作为android动画的最后一期介绍了TypeEvaluator和TimeInterpolate相关的内容，这部分算是android动画的高级部分，通过自定义完成我们现实项目中需求。","tags":[{"name":"Android","slug":"Android","permalink":"//dongqing123.cn/tags/Android/"},{"name":"动画","slug":"动画","permalink":"//dongqing123.cn/tags/动画/"}]},{"title":"android动画（二）","date":"2017-03-24T06:38:14.000Z","path":"2017/03/24/android动画-二/","text":"上一篇android动画（一）我们介绍了补间动画与逐帧动画，今天我们介绍android的属性动画。android属性动画大约会使用到如下类 ValueAnimator ObjectAnimator AnimatorSet AnimatorInflater TypeEvaluator TimeInterpolate ValueAnimator是属性动画中的核心类，只需要传入初始值与结束值就可以了，ValueAnimator自己会通过某种机制实现动画的过渡。123ValueAnimator anim = ValueAnimator.ofFloat(0f, 1f); anim.setDuration(300); anim.start(); 这样就实现了动画经过3s从0变化到1，当然我们可以通过监听器监听动画12345678910ValueAnimator anim = ValueAnimator.ofFloat(0f, 1f); anim.setDuration(300); anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float currentValue = (float) animation.getAnimatedValue(); Log.d(\"TAG\", \"cuurent value is \" + currentValue); &#125; &#125;); anim.start(); 这里我们通过打印log的形式来查看动画的执行情况，实际使用中可能是具体的操作如移动、渐变、旋转、缩放等等。 ValueAnimator除了提供offFloat还提供了其他的方法 ValueAnimator ofFloat(float… values)：接收一系列的float类型的值,对应TypeEvaluator为FloatEvaluator ValueAnimator ofInt(int… values)：ofInt方法与ofFloat方法很类似，只不过ofInt方法接收int类型的值，对应TypeEvaluator为IntEvaluator ValueAnimator ofArgb(int… values) ：api21引入，该方法接收一些列代表了颜色的int值，对应TypeEvaluator为ArgbEvaluator ValueAnimator ofObject(TypeEvaluator evaluator, Object… values)：除了上述那些，我们还可以通过ofObject实现任意的动画。 我们出了使用setDuration设置动画时间外，还可以动画的延迟时间setStartDelay，循环播放次数setRepeatCount和循环播放的模式setRepeatMode。 ObjectAnimator相对于ValueAnimator也许我们更常用的是它，它可以直接对任意对象的任意属性进行动画操作。不过查看ObjectAnimator源码发现其实它俩是继承关系，ObjectAnimator是继承ValueAnimator来的。因此在用法上比较类似。123ObjectAnimator animator = ObjectAnimator.ofFloat(textView, \"alpha\", 1f, 0f, 1f); animator.setDuration(5000); animator.start(); 上述代码便能实现textView在5s内的透明度从1——&gt;0——&gt;1。比较我们我们发现参数发生了些许变化，需要接受一个对象和属性。 ObjectAnimator ofFloat(Object target, String propertyName, float… values) ObjectAnimator ofInt(Object target, String propertyName, int… values) ObjectAnimator ofArgb(Object target, String propertyName, int… values) ObjectAnimator ofObject(Object target, String propertyName, TypeEvaluator evaluator, Object… values) 我们用一个例子对比一下ValueAnimator与ObjectAnimator的区别ValueAnimator实现平移12345678910ValueAnimator anim = ValueAnimator.ofFloat(0, 500); anim.setDuration(500); anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float currentValue = (float) animation.getAnimatedValue(); textView.setTranslationX(currentValue) &#125; &#125;); anim.start(); ObjectAnimator实现平移123ObjectAnimator animator = ObjectAnimator.ofFloat(textView, \"translationX\", 0,500); animator.setDuration(500); animator.start(); 区别就在于ObjectAnimator多了object与propertyName两个参数，如果需要更新对象中属性，那么该对象必须具有set、get属性的方法。当只填入一个值时该值会作为终止值，那么需要调用get方法获取属性值作为初始值。通过查看View的源码发现补间动画的相应属性都有，因此ObjectAnimator可以用来实现。 translationX：x轴平移 translationY：y轴平移 alpha：透明度 scaleX：x轴缩放 scaleY：y轴缩放 rotation：旋转 当然我们也可自定义属性，不过要相应属性的set与get方法，这样便可以通过ObjectAnimator实现对应的动画操作。 AnimatorSet现实生活中单一动画的操作毕竟比较少，一般都是很多动画同时或顺序执行，来达到我们想要的效果，这时候就需要AnimatorSet类来实现组合动画。主要有如下几个方法 AnimatorSet.Builder play(Animator anim)：执行动画 void playTogether(Animator… items)：同时执行动画 void playTogether(Collection items)：同时执行动画 void playSequentially(Animator… items)：顺序执行动画 void playSequentially(List items)：顺序执行动画 通过play()方法返回一个AnimatorSet.Builder的实例，该类包括以下方法 AnimatorSet.Builder with(Animator anim)：将现有动画和传入的动画同时执行 AnimatorSet.Builder before(Animator anim)：将现有动画插入到传入的动画之前执行 AnimatorSet.Builder after(Animator anim)：将现有动画插入到传入的动画之后执行 AnimatorSet.Builder after(long delay)：将现有动画延迟指定毫秒后执行 那么我们现在就实现一组动画，比如先旋转再放大，放大的同时淡入淡出。12345678ObjectAnimator rotale = ObjectAnimator.ofFloat(image, \"rotation\", 0, 360f); ObjectAnimator scaleX = ObjectAnimator.ofFloat(image, \"scaleX\", 1f, 3f, 1f); ObjectAnimator scaleY = ObjectAnimator.ofFloat(image, \"scaleY\", 1f, 3f, 1f); ObjectAnimator alpha = ObjectAnimator.ofFloat(textview, \"alpha\", 1f, 0f, 1f); AnimatorSet animSet = new AnimatorSet(); animSet.play(scaleX).with(scaleY).with(alpha).after(rotale); animSet.setDuration(5000);animSet.start(); 对于动画的执行我们可以设置监听器123456789101112131415161718192021anim.addListener(new AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; //动画开始 &#125; @Override public void onAnimationRepeat(Animator animation) &#123; //动画循环 &#125; @Override public void onAnimationEnd(Animator animation) &#123; //动画完成 &#125; @Override public void onAnimationCancel(Animator animation) &#123; //动画取消 &#125; &#125;); 由于AnimatorListener是接口因此你可能觉得实现起来太繁琐，android为我们提供了一个抽象类AnimatorListenerAdapter，我们只需要重写我们想要的部分就可以了。 AnimatorInflater属性动画除了通过代码实现以外，还可以像补间动画一样通过xml来实现一些常用的动画效果。首先我们需要在res目录下新建animator文件夹，用于存放所有的属性动画。常使用的标签主要有如下： animator：对应代码中的ValueAnimator objectAnimator：对应代码中的ObjectAnimator set：对应代码中的AnimatorSet 例如我们要实现一个过渡动画1234&lt;animator xmlns:android=\"http://schemas.android.com/apk/res/android\" android:valueFrom=\"0\" android:valueTo=\"100\" android:valueType=\"floatType\"/&gt; valueType用于指定TypeEvaluator，因此floatType：对于ofFloatintType：对应ofIntcolorType：对应ofArgb如果我们要实现实现补间动画的效果则可以通过如下12345&lt;objectAnimator xmlns:android=\"http://schemas.android.com/apk/res/android\" android:valueFrom=\"0\" android:valueTo=\"0\" android:valueType=\"floatType\" android:propertyName=\"alpha\"/&gt; 这样就实现了透明度的渐变当然我们可以指定如下view的属性 translationX：x轴平移 translationY：y轴平移 alpha：透明度 scaleX：x轴缩放 scaleY：y轴缩放 rotation：旋转 当然我么可以通过set标签来实现组合动画，如先旋转再放大，放大的同时淡入淡出。123456789101112131415161718192021222324252627282930313233343536373839&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:ordering=\"sequentially\"&gt; &lt;objectAnimator android:duration=\"1000\" android:propertyName=\"rotation\" android:valueFrom=\"0\" android:valueTo=\"360\" android:valueType=\"floatType\" /&gt; &lt;set android:ordering=\"together\"&gt; &lt;set android:ordering=\"together\"&gt; &lt;objectAnimator android:duration=\"2000\" android:propertyName=\"scaleX\" android:valueFrom=\"1.0f\" android:valueTo=\"3.0f\" android:valueType=\"floatType\" /&gt; &lt;objectAnimator android:duration=\"2000\" android:propertyName=\"scaleY\" android:valueFrom=\"1.0f\" android:valueTo=\"3.0f\" android:valueType=\"floatType\" /&gt; &lt;/set&gt; &lt;set android:ordering=\"sequentially\"&gt; &lt;objectAnimator android:duration=\"1000\" android:propertyName=\"alpha\" android:valueFrom=\"1\" android:valueTo=\"0\" android:valueType=\"floatType\" /&gt; &lt;objectAnimator android:duration=\"1000\" android:propertyName=\"alpha\" android:valueFrom=\"0\" android:valueTo=\"1\" android:valueType=\"floatType\" /&gt; &lt;/set&gt; &lt;/set&gt;&lt;/set&gt; 旋转时还有基点pivotX与pivotY，默认是中心点，rotationX与rotationY则是立体的旋转。感觉写起来是不是没有代码方便呢，若是经常使用的动画建议使用xml，否则还是代码写起来方便。动画写好了还只是一半，我们还要通过加载执行动画123Animator animator=AnimatorInflater.loadAnimator(context, R.animator.anim_file);animator.setTarget(view);animtor.start(); 通过AnimatorInflater加载布局xml动画，setTarget知道对象，stat启动动画。 ViewPropertyAnimatorViewPropertyAnimator是android3.1新增的功能，是专门为view提供的一种便捷用法。对比ObjectAnimator使用起来更加简洁。调用对应属性方法传一个属性值就可以自动实现动画。每个属性方法都有两种调用形式，例如 alpha(float value) 和alphaBy(float value)，前者是变化到多少，后者是变化多少。总结起来就是： 这个类操作View对象的 提供链式调用设置多个属性动画，这些动画同时进行的 更好的性能，多个属性动画是一次同时变化，只执行一次UI刷新。 每个属性提供两种类型方法设置。 这个类只能通过View的animate()获取引用进行动画设置。 使用形式12345imageView.animate() .setDuration(4000) .rotationY(45f) .translationX(imageView.getWidth()) .alpha(0f); ObjectAnimator等价形式12345AnimatorSet animSet = new AnimatorSet(); animSet.playTogether( ObjectAnimator.ofFloat(imageView, \"translationX\", imageView.getWidth()), ObjectAnimator.ofFloat(imageView, \"alpha\", 0), ObjectAnimator.ofFloat(imageView, \"rotationY\", 45f)); 对比起来，使用ViewPropertyAnimator更加简洁。 最后TypeEvaluator与TimeInterpolate是属性动画的高级部分，我们放到下期再讲，顺便把遗漏的ofObject进行分析。","tags":[{"name":"Android","slug":"Android","permalink":"//dongqing123.cn/tags/Android/"},{"name":"动画","slug":"动画","permalink":"//dongqing123.cn/tags/动画/"}]},{"title":"android 进程间通信之AIDL","date":"2017-03-17T08:35:31.000Z","path":"2017/03/17/android-进程间通信之AIDL/","text":"最近一直在想微信与支付宝这样的sdk是怎么做到支付回调的，明明是两个不同的apk，接口、StartActivityForResult什么的肯定是行不通的。忽然想到会不会使用了跨进程通信的机制，客户端给支付宝发送支付请求，支付宝通过回调将支付结果回传给客户端，从而实现连个apk支付的回调。竟然是这么想的，就不如大胆的实践一下吧！我们先说一说我想实现的效果A.apk通过点击跳转到B.apk,然后传递相应的消息，然后B通过点击把消息回传给A。 效果图 服务器apk首先我们新建一个工程作为服务器apk然后使用android studio新建aidl文件 12345678910111213141516// IRemoteServiceCallback.aidlpackage com.dongqing.aidlservice;/** * a callback interface used by dvbService to send * synchronous notifications back to its clients. Note that this is a * one-way interface so the server does not block waiting for the client. */oneway interface IRemoteServiceCallback &#123; /* * handler search message from service */ void handlerSearchEvent(int msgID, String msg);&#125; IRemoteServiceCallback顾名思义用于回调给客户端的接口，然后我们建立IRemoteService.aidl1234567891011// IRemoteService.aidlpackage com.dongqing.aidlservice;//import 必须添加，就算是一个包import com.dongqing.aidlservice.IRemoteServiceCallback;// Declare any non-default types here with import statementsinterface IRemoteService &#123; void registerCallback(IRemoteServiceCallback callback); void sendMsgCallback(IRemoteServiceCallback callback);&#125; IRemoteService用于注册回调接口，然后我们Make Project，android studio会自动帮助我们生成其相应的 java文件然后我们新建一个service用于客户端与服务器通信1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class AIDLService extends Service &#123; String TAG = AIDLService.class.getSimpleName(); private RemoteCallbackList&lt;IRemoteServiceCallback&gt; mCallbacks = new RemoteCallbackList&lt;IRemoteServiceCallback&gt;(); private HandlerThread handlerThread; private Messenger msg; @Override public void onCreate() &#123; super.onCreate(); handlerThread = new HandlerThread(\"handle\"); handlerThread.start(); msg = new Messenger(new Handler(handlerThread.getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); Bundle bundle = msg.getData(); if (msg.what == 1001) &#123; result = bundle.getString(\"data\"); Log.v(TAG, result); &#125; sendMsg(); &#125; &#125;); &#125; private IRemoteService.Stub binder = new IRemoteService.Stub() &#123; @Override public void registerCallback(IRemoteServiceCallback callback) throws RemoteException &#123; if (callback != null) &#123; mCallbacks.register(callback); &#125; &#125; @Override public void sendMsgCallback(IRemoteServiceCallback callback) throws RemoteException &#123; &#125; &#125;; public void sendMsg() &#123; // Broadcast to all clients the new value. final int N = mCallbacks.beginBroadcast(); try &#123; for (int i = 0; i &lt; N; i++) &#123; mCallbacks.getBroadcastItem(i).handlerSearchEvent(1, \"service callback client\"); &#125; &#125; catch (RemoteException e) &#123; &#125; mCallbacks.finishBroadcast(); &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; if ((\"com.dongqing.aidl\").equals(intent.getAction())) &#123; return binder; &#125; if ((\"com.dongqing.messenger\").equals(intent.getAction())) &#123; return msg.getBinder(); &#125; return null; &#125;&#125; 我们通过Messenger用来处理Activity与本地service通信，使用RemoteCallbackList处理异步回调。现在我们在配置文件注册我们的service1234567&lt;service android:name=\".AIDLService\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.dongqing.aidl\" /&gt; &lt;action android:name=\"com.dongqing.messenger\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;/intent-filter&gt;&lt;/service&gt; 我们指定action，这样可以通过action隐式的绑定其service。然后我们在服务器的Activity中1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; String TAG = MainActivity.class.getName(); private Button button; private TextView textView; private Messenger mService; boolean isBind; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); bindService(); &#125; private void initView() &#123; button = (Button) findViewById(R.id.button); button.setOnClickListener(this); textView = (TextView) findViewById(R.id.textView); Bundle bundle=getIntent().getExtras(); if(bundle!=null)&#123; Log.v(TAG,bundle.getString(\"data\")); textView.setText(bundle.getString(\"data\")); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button: Message msgFromClient = Message.obtain(null,1001); Bundle bundle = new Bundle(); // 因为bundle实现了Parcelable接口。 bundle.putString(\"data\", \"OK\"); msgFromClient.setData(bundle); if(isBind)&#123; try &#123; mService.send(msgFromClient); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; finish(); break; &#125; &#125; private void bindService() &#123; Intent intent = new Intent(this,AIDLService.class); intent.setAction(\"com.dongqing.messenger\"); bindService(intent, conn, Context.BIND_AUTO_CREATE); &#125; private ServiceConnection conn=new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; mService=new Messenger(iBinder); isBind=true; &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; isBind=false; &#125; &#125;; @Override protected void onDestroy() &#123; super.onDestroy(); unbindService(conn); &#125;&#125; 首先我们绑定本地的service，通过button的点击事件模拟支付成功的回调。点击时我们通过Messenger给service发送一个消息，service收到消息后通过RemoteCallbackList调用回调函数handlerSearchEvent实现服务端给客户端发送异步消息。 客户端apk首先我们新建一个工程作为客户端apk，然后需要把服务端aidl的文件夹拷贝到相同的目录下。然后在Activity1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; String TAG = MainActivity.class.getName(); private IRemoteService mService; boolean isBind; private Button button; private TextView textView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); BindService(); &#125; private void BindService() &#123; Intent intent = new Intent(); intent.setAction(\"com.dongqing.aidl\"); intent.setPackage(\"com.dongqing.aidlservice\"); bindService(intent, sc, Context.BIND_AUTO_CREATE); &#125; private ServiceConnection sc = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; mService = IRemoteService.Stub.asInterface(iBinder); isBind = true; if (mService != null) &#123; try &#123; mService.registerCallback(mCallback); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; isBind = false; mService = null; &#125; &#125;; private IRemoteServiceCallback.Stub mCallback = new IRemoteServiceCallback.Stub() &#123; @Override public void handlerSearchEvent(int msgID, String msg) throws RemoteException &#123;// Toast.makeText(getContext(), msg, Toast.LENGTH_SHORT).show(); Log.v(TAG, msg); runOnUiThread(new Runnable() &#123; @Override public void run() &#123; textView.setText(msg); &#125; &#125;); &#125; &#125;; private void initView() &#123; button = (Button) findViewById(R.id.button); button.setOnClickListener(this); textView = (TextView) findViewById(R.id.textView); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button: try &#123; Intent intent = getPackageManager().getLaunchIntentForPackage(\"com.dongqing.aidlservice\"); intent.putExtra(\"data\",\"client to service\"); startActivity(intent); if (isBind) &#123; if (mService != null &amp;&amp; mCallback != null) &#123; mService.sendMsgCallback(mCallback); &#125; &#125; &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; break; &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if (isBind) &#123; unbindService(sc); &#125; &#125; public Context getContext() &#123; return this; &#125;&#125; 通过绑定service，实现回调callback方法，便可以实现客户端apk与服务器apk之间的相互通信。 流程首先客户端需要绑定服务端的service，通过startIntent传递传递参数给服务端的Activity，并且注册回调接口。服务端拿到传递过来的数据进行一系列的操作，当点击按钮是通过Messenger向service传递数据，service收到Activity传递来的数据后，通过RemoteCallbackList调用回调的接口将接受到的数据传递给客户端的Activity，这样便实现了两个apk时间Activity的通信。 最后通过一系列的实践与测试实现了apk之间的通信，但是不清楚支付宝、微信等sdk是不是以这种方式实现。这里仅仅是通过学习AIDL实现了类似于这种apk之间异步操作的通信，当然说不定有其他实现的方式。","tags":[{"name":"Android","slug":"Android","permalink":"//dongqing123.cn/tags/Android/"},{"name":"AIDL","slug":"AIDL","permalink":"//dongqing123.cn/tags/AIDL/"},{"name":"进程通信","slug":"进程通信","permalink":"//dongqing123.cn/tags/进程通信/"}]},{"title":"android动画（一）","date":"2017-03-15T08:36:26.000Z","path":"2017/03/15/android动画-一/","text":"android动画主要分为三类：补间动画（Tween Animation）、逐帧动画（Frame Animation或Drawable Animation）和属性动画（Property Animation）。补间动画我们平时用的比较多，主要用于简单的缩放、平移、旋转、透明度基本的动画。逐帧动画主要是通过一张张的图片来产生动画效果，如我们自定义刷新的菊花图等等属性动画是android3.0添加了一种新的动画方式，之前还在用nineoldandroids来兼容android3.0以下的版本，不过现在2.2的系统基本上没有了。今天我们介绍较为简单的补间与逐帧动画。通常我们在res目录新建anim的文件夹用于存放动画的xml文件 Tween Animation 缩放12345678&lt;scale xmlns:android=\"http://schemas.adnroid.com/apk/res/android\" android:fromXScale=\"1.0\"//缩放x轴比例 android:toXScale=\"3.0\" android:fromYScale=\"1.0\"//缩放y轴比例 android:toYScale=\"3.0\" android:pivotX=\"50%\"//缩放起点X轴坐标，可以是数值、百分数、百分数p 三种样式 android:pivotY=\"50%\"//缩放起点Y轴坐标/&gt; 除了这些还有这些共有动画属性 android:repeatCount 重复次数 android:repeatMode 重复类型，有reverse和restart两个值，reverse表示倒序回放，restart表示重新放一遍,必须与repeatCount一起使用才能看到效果。 android:fillAfter 如果设置为true，控件动画结束时，将保持动画最后时的状态 android:fillBefore 如果设置为true,控件动画结束时，还原到开始动画前的状态 android:fillEnabled 与fillBefore 效果相同。 android:interpolator 设定插值器（也叫补间器）。 android:duration 动画持续时间，以毫秒为单位 插值器可以让动画按照一定的频率运动，实现加速、加速、重复、回弹等效果。常用插值器及使用 插值器 资源ID(@android:anim/) 说明 AccelerateDecelerateInterpolator accelerate_decelerate_interpolator 在动画开始与结束的地方速率改变比较慢，在中间的时候加速 AccelerateInterpolator accelerate_interpolator 在动画开始的地方速率改变比较慢，然后开始加速 AnticipateInterpolator anticipate_interpolator 开始的时候向后然后向前甩 AnticipateOvershootInterpolator anticipate_overshoot_interpolator 开始的时候向后然后向前甩一定值后返回最后的值 BounceInterpolator bounce_interpolator 动画结束的时候弹起 CycleInterpolator cycle_interpolator 动画循环播放特定的次数，速率改变沿着正弦曲线 DecelerateInterpolator decelerate_interpolator 在动画开始的地方快然后慢 LinearInterpolator linear_interpolator 以常量速率改变 OvershootInterpolator overshoot_interpolator 向前甩一定值后再回到原来位置 平移 1234567&lt;translate xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"300\" android:fromXDelta=\"0\"//起始点X轴坐标，可以是数值、百分数、百分数p 三种样式 android:toXDelta=\"100%p\"//结束点X轴坐标 android:fromYDelta=\"0\"//起始点Y轴坐标 android:toYDelta=\"100%p\"// 结束点Y轴坐标/&gt; 旋转 1234567&lt;rotate xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"300\" android:fromDegrees=\"0\"//开始旋转的角度位置，正值代表顺时针方向度数，负值代码逆时针方向度数 android:toDegrees=\"360\"//结束时旋转到的角度位置 android:pivotY=\"50%\"// 旋转起点X轴坐标，可以是数值、百分数、百分数p 三种样式 android:pivotX=\"50%\" //旋转起点Y轴坐标/&gt; 透明度 12345&lt;alpha xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"300\" android:fromAlpha=\"0.1\"//动画开始的透明度，从0.0 --1.0 ，0.0表示全透明，1.0表示完全不透明 android:toAlpha=\"1\"//动画结束时的透明度/&gt; 5.组合动画在实际使用中我们往往需要几种动画同时产生效果，比如需要图片有小到大、旋转加渐变显示，这时候单一的动画效果已经不能满足我们的需求了。这时候我们就需要使用组合动画的标签set12345678910111213141516171819&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"500\" android:fillAfter=\"true\"&gt; &lt;scale android:fromXScale=\"0\" android:fromYScale=\"0\" android:pivotX=\"50%\" android:pivotY=\"50%\" android:toXScale=\"1\" android:toYScale=\"1\" /&gt; &lt;rotate android:fromDegrees=\"0\" android:pivotX=\"50%\" android:pivotY=\"50%\" android:toDegrees=\"360\" /&gt; &lt;alpha android:fromAlpha=\"0\" android:toAlpha=\"1\" /&gt;&lt;/set&gt; 当然除了将动画现在xml中，也可通过纯Java来实现，起对应关系如下 动画类型 xml配置 纯Java 透明度 &lt; alpha /&gt; AlphaAnimation 缩放 &lt; scale /&gt; ScaleAnimation 旋转 &lt; rotate /&gt; RotateAnimation 移动 &lt; translate /&gt; TranslateAnimation 组合动画 &lt; set /&gt; AnimationSet Activity中主要通过以下代码调用123456789101112131415161718192021//加载动画资源Animation anim= AnimationUtils.loadAnimation(this,R.anim.anim);//开始动画anim.start();//监听动画anim.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; &#125; @Override public void onAnimationEnd(Animation animation) &#123; &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125;&#125;); Frame Animation逐帧动画主要是通过animation-list标签实现12345678&lt;animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\" android:oneshot=\"false\"&gt;//动画是否循环播放 &lt;item android:drawable=\"@mipmap/loading_1\" android:duration=\"50\"/&gt;//drawable是图片资源、duration为时间 &lt;item android:drawable=\"@mipmap/loading_2\" android:duration=\"50\"/&gt; &lt;item android:drawable=\"@mipmap/loading_3\" android:duration=\"50\"/&gt; &lt;item android:drawable=\"@mipmap/loading_4\" android:duration=\"50\"/&gt; &lt;item android:drawable=\"@mipmap/loading_5\" android:duration=\"50\"/&gt;&lt;/animation-list&gt; 然后在布局文件12345&lt;ImageView android:id=\"@+id/image\" android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:src=\"@drawable/anim\"/&gt; 最后123ImageView iv=(ImageView)findViewById(R.id.image);AnimationDrawable ad = (AnimationDrawable) iv.getDrawable(); iv.start(); 这期我们就简单介绍动画的类型，以及基本的动画实现，下期我们介绍属性动画的相关内容。","tags":[{"name":"Android","slug":"Android","permalink":"//dongqing123.cn/tags/Android/"},{"name":"动画","slug":"动画","permalink":"//dongqing123.cn/tags/动画/"}]},{"title":"数据库greenDAO的使用（四）","date":"2017-03-13T09:12:25.000Z","path":"2017/03/13/数据库greenDAO的使用-四/","text":"上一篇数据库greenDAO的使用（三）我们介绍了greenDAO数据库的升级问题，并且自定义了数据库的路径，当时我们就提到放在sd卡上如何保证数据库的安全，今天我们就使用greenDAO的加密技术解决安全问题。首先添加加密所需的依赖库1234dependencies &#123; ... compile 'net.zetetic:android-database-sqlcipher:3.5.1'&#125; 我们只需要简单的修改GreenDaoManager的init方法123456private void init() &#123; SQLiteOpenHelper devOpenHelper = new SQLiteOpenHelper(new GreenDaoContext(), \"scale.db\");// mDaoMaster = new DaoMaster(devOpenHelper.getWritableDatabase()); mDaoMaster=new DaoMaster(devOpenHelper.getEncryptedWritableDb(\"secret\")); mDaoSession = mDaoMaster.newSession();&#125; 使用getEncryptedWritableDb便可让数据库加密，参数为秘钥的字符串或字符数组。这样我们便看不到数据库里面的数据了。到这里greenDAO的使用就全部结束了。","tags":[{"name":"Android","slug":"Android","permalink":"//dongqing123.cn/tags/Android/"},{"name":"数据库","slug":"数据库","permalink":"//dongqing123.cn/tags/数据库/"},{"name":"greenDAO","slug":"greenDAO","permalink":"//dongqing123.cn/tags/greenDAO/"}]},{"title":"数据库greenDAO的使用（三）","date":"2017-03-10T02:04:50.000Z","path":"2017/03/10/数据库greenDAO的使用-三/","text":"上一篇数据库greenDAO的使用（二）介绍的数据库的基本操作，今天我们便介绍数据库升级的问题。当我们的应用已投入使用，新版本中修改了表结构、或者增加了表，这时候我们就修改考虑数据库升级的问题了。这是如果我们不修改数据库版本肯定会crash，但是仅仅只是修改版本的话是不行的。查看DaoMaster代码发现1234567891011121314151617/** WARNING: Drops all table on Upgrade! Use only during development. */public static class DevOpenHelper extends OpenHelper &#123; public DevOpenHelper(Context context, String name) &#123; super(context, name); &#125; public DevOpenHelper(Context context, String name, CursorFactory factory) &#123; super(context, name, factory); &#125; @Override public void onUpgrade(Database db, int oldVersion, int newVersion) &#123; Log.i(\"greenDAO\", \"Upgrading schema from version \" + oldVersion + \" to \" + newVersion + \" by dropping all tables\"); dropAllTables(db, true); onCreate(db); &#125;&#125; 它竟然删除了所有的表，然后重新创建，这样数据肯定就没有了。因此我们需要自定义一个help来实现DaoMaster.OpenHelper（DaoMaster是自动生成的）1234567891011121314public class SQLiteOpenHelper extends DaoMaster.OpenHelper &#123; public SQLiteOpenHelper(Context context, String name) &#123; super(context, name); &#125; public SQLiteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory) &#123; super(context, name, factory); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; super.onUpgrade(db, oldVersion, newVersion); &#125;&#125; 然后在GreenDaoManager类中修改init1234567private void init()&#123;// DaoMaster.DevOpenHelper devOpenHelper = new DaoMaster.DevOpenHelper(App.getAppContext(), \"test.db\"); SQLiteOpenHelper devOpenHelper = new SQLiteOpenHelper(App.getAppContext(), \"test.db\"); mDaoMaster = new DaoMaster(devOpenHelper.getWritableDatabase()); mDaoSession = mDaoMaster.newSession();&#125; 这样就会使用我们自已的OpenHelpe类了，那么问题来了，怎么升级数据库。首先我们需要一个临时数据库，将我们旧数据库备份到临时数据库中，然后删除旧数据库，建立新数据库，然后恢复临时库到新数据库中，最后删掉临时数据库。说起来简单，怎么做呢？果断google，皇天不负有心人啊stackoverflow上有人给出了解决方案http://stackoverflow.com/questions/13373170/greendao-schema-update-and-data-migration ，而且有人放到了github上面https://github.com/yuweiguocn/GreenDaoUpgradeHelper ，这样我们的问题就迎刃而解了。因此我们需要修改我们的SQLiteOpenHelper，假设我们1.0版本的实体类为123456789@Entitypublic class User &#123; @Id(autoincrement = true) private Long id; private String name; //@Transient private String sex; private Integer age;&#125; 在2.0中我们添加注释及字段sex不在表中，并且增加了新的实体123456789@Entitypublic class Food &#123; @Id(autoincrement = true) private Long id; private String name; private String price; private String weight; private String total;&#125; 这样新的数据库中应该有两张表并且User中添加了一个新的sex字段。 首先我们修改gradle的配置，将数据库的版本+112345greendao &#123; schemaVersion 2 daoPackage 'com.greendao.gen' targetGenDir 'src/main/java'&#125; 然后我们修改SQLiteOpenHelper的方法12345@Overridepublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;// super.onUpgrade(db, oldVersion, newVersion); MigrationHelper.migrate(db,UserDao.class, FoodDao.class);&#125; 这样当有新版本的数据库时便执行onUpgrade方法实现数据库的升级。现在我们就测试一下首先我们第一版本中插一条数据12345UserDao userDao = GreenDaoManager.getInstance().getmDaoSession().getUserDao();userDao.insert(new User(null, \"黎明\",18));if(userDao.loadAll().size()&gt;0)&#123; text.setText(userDao.loadAll().get(0).getName());&#125; 我们查看运行效果，导出数据库查看数据 现在我们升级数据库首先看新的数据库中旧数据存在没有12345UserDao userDao = GreenDaoManager.getInstance().getmDaoSession().getUserDao();List&lt;User&gt;list=userDao.queryBuilder().where(UserDao.Properties.Name.eq(\"黎明\")).list();if(list.size()!=0)&#123; text.setText(list.get(0).getName());&#125; 可以看到升级成功旧数据还存在，并且数据库User表结构增加了sex字段，也添加了food表。 现在我们便可以愉快的操作新版了12345678910111213141516171819202122232425UserDao userDao = GreenDaoManager.getInstance().getmDaoSession().getUserDao();List&lt;User&gt;list=userDao.queryBuilder().where(UserDao.Properties.Name.eq(\"黎明\")).list();if(list.size()!=0)&#123; User user=list.get(0); user.setSex(\"男\"); userDao.update(user);&#125;FoodDao foodDao=GreenDaoManager.getInstance().getmDaoSession().getFoodDao();Food food=new Food(null,\"白菜\",\"1.60\",\"2.00\",\"3.20\");foodDao.insert(food);StringBuilder sb=new StringBuilder();if(userDao.loadByRowId(1)!=null)&#123; sb.append(\"User: \"); sb.append(userDao.loadByRowId(1).getName()+\" \"); sb.append(userDao.loadByRowId(1).getSex()+\"\\n\");&#125;if(foodDao.loadByRowId(1)!=null)&#123; sb.append(\"Food: \"); sb.append(foodDao.loadByRowId(1).getName()+\" \"); sb.append(foodDao.loadByRowId(1).getPrice()+\" \"); sb.append(foodDao.loadByRowId(1).getWeight()+\" \"); sb.append(foodDao.loadByRowId(1).getTotal()+\"\\n\");&#125;text.setText(sb.toString()); 是不是都成功了呢，这样我们升级数据库的大任就此结束了。当然可能有人会问，如果我用真机该如何导出数据库呢，是有办法的，我们是可以修改数据库的位置的。我们新建一个类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class GreenDaoContext extends ContextWrapper &#123; private String currentUserId; private Context mContext; public GreenDaoContext() &#123; super(App.getInstance().getApplicationContext()); this.mContext = App.getInstance().getApplicationContext(); this.currentUserId = \"greendao\";//目录 &#125; /** * 获得数据库路径，如果不存在，则创建对象 * * @param dbName */ @Override public File getDatabasePath(String dbName) &#123; File baseFile = new File(\"/sdcard\"); StringBuffer buffer = new StringBuffer(); buffer.append(baseFile.getPath()); buffer.append(File.separator); buffer.append(currentUserId); String dbDir = buffer.toString();// 数据库所在目录 buffer.append(File.separator); buffer.append(dbName); File dirFile = new File(dbDir); if (!dirFile.exists())&#123; dirFile.mkdirs(); &#125; return new File(buffer.toString()); &#125; /** * 重载这个方法，是用来打开SD卡上的数据库的，android 2.3及以下会调用这个方法。 * * @param name * @param mode * @param factory */ @Override public SQLiteDatabase openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory) &#123; SQLiteDatabase result = SQLiteDatabase.openOrCreateDatabase(getDatabasePath(name), factory); return result; &#125; /** * Android 4.0会调用此方法获取数据库。 * * @param name * @param mode * @param factory * @param errorHandler * @see android.content.ContextWrapper#openOrCreateDatabase(java.lang.String, int, * android.database.sqlite.SQLiteDatabase.CursorFactory, * android.database.DatabaseErrorHandler) */ @Override public SQLiteDatabase openOrCreateDatabase(String name, int mode, SQLiteDatabase.CursorFactory factory, DatabaseErrorHandler errorHandler) &#123; SQLiteDatabase result = SQLiteDatabase.openOrCreateDatabase(getDatabasePath(name), factory); return result; &#125;&#125; 然后修改GreenDaoManager中init方法1234567private void init()&#123;// DaoMaster.DevOpenHelper devOpenHelper = new DaoMaster.DevOpenHelper(App.getAppContext(), \"test.db\"); SQLiteOpenHelper devOpenHelper = new SQLiteOpenHelper(/*App.getAppContext()*/new GreenDaoContext(), \"test.db\"); mDaoMaster = new DaoMaster(devOpenHelper.getWritableDatabase()); mDaoSession = mDaoMaster.newSession();&#125; 当然我们不要忘记添加SD卡的读写权限，这样我们便可以在指定的目录下查看我们的数据库了。您可能会担心数据的安全问题，放在SD卡上不就可以人人查看了吗？不用担心，下期我们介绍greenDAO数据库的加密。","tags":[{"name":"Android","slug":"Android","permalink":"//dongqing123.cn/tags/Android/"},{"name":"数据库","slug":"数据库","permalink":"//dongqing123.cn/tags/数据库/"},{"name":"greenDAO","slug":"greenDAO","permalink":"//dongqing123.cn/tags/greenDAO/"}]},{"title":"数据库greenDAO的使用（二）","date":"2017-03-09T02:02:10.000Z","path":"2017/03/09/数据库greenDAO的使用-二/","text":"上一篇数据库greenDAO的使用（一）我们介绍了greenDAO的相关配置与注解，现在开始介绍数据的操作增、删、查、改。首先我们新建一个实体类12345678910@Entitypublic class User &#123; @Id(autoincrement = true) private Long id; private String name; @Transient private String sex; //@Transient private Integer age;&#125; 点击工具栏Build菜单下的Make Project（Mac快捷键 ⌘F9 )，项目会自动构建，在我们设置的daoPackage（默认包名.gen）目录下生成相应的DaoMaster、DaoSession及UserDao，相应的Uer类也会自动生成构造与set、get方法。然后我们定义一个管理类用于获取DaoMaster与DaoSession123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class GreenDaoManager&#123; private DaoMaster mDaoMaster; private DaoSession mDaoSession; private GreenDaoManager() &#123; init(); &#125; /** * 静态内部类，实例化对象使用 */ private static class SingleInstanceHolder &#123; private static final GreenDaoManager INSTANCE = new GreenDaoManager(); &#125; /** * 对外唯一实例的接口 * * @return */ public static GreenDaoManager getInstance() &#123; return SingleInstanceHolder.INSTANCE; &#125; /** * 初始化数据 */ private void init() &#123; DaoMaster.DevOpenHelper devOpenHelper = new DaoMaster.DevOpenHelper(App.getAppContext(), \"test.db\"); mDaoMaster = new DaoMaster(devOpenHelper.getWritableDatabase()); mDaoSession = mDaoMaster.newSession(); &#125; public DaoMaster getmDaoMaster() &#123; return mDaoMaster; &#125; public DaoSession getmDaoSession() &#123; return mDaoSession; &#125; public DaoSession getNewSession() &#123; mDaoSession = mDaoMaster.newSession(); return mDaoSession; &#125;&#125; 在这里我们需要自定义application1234567891011121314151617public class App extends Application &#123; private static App INSTANCE; public static App getInstance() &#123; return INSTANCE; &#125; @Override public void onCreate() &#123; super.onCreate(); INSTANCE = this; GreenDaoManager.getInstance(); &#125; public static Context getAppContext()&#123; return INSTANCE.getApplicationContext(); &#125;&#125; 这样基本的配置结结束了AbstractDao常用方法 增 insert(T entity)：将给定的实体插入数据库 insertWithoutSettingPk(T entity)：将给定的实体插入数据库,但不设定主键 insertInTx(Iterable entities)：使用事务操作，将给定的实体集合插入数据库 insertInTx(Iterable entities, boolean setPrimaryKey)使用事务操作，将给定的实体集合插入数据库， 并设置是否设定主键 insertInTx(T… entities)：将给定的实体插入数据库 insertOrReplace(T entity)：将给定的实体插入数据库，若此实体存在，则覆盖 insertOrReplaceInTx(Iterable entities)：使用事务操作，将给定的实体插入数据库，若此实体存在则覆盖 insertOrReplaceInTx(Iterable entities, boolean setPrimaryKey)使用事务操作，将给定的实体插入数据库，若此实体存在则覆盖，并设置是否设定主键 insertOrReplaceInTx(T… entities)：用事务操作，将给定的实体插入数据库，若此实体类在则覆盖 12345UserDao userDao = GreenDaoManager.getInstance().getmDaoSession().getUserDao();userDao.insert(new User(null, \"黎明\",18));if(userDao.loadAll().size()&gt;0)&#123; ext.setText(userDao.loadAll().get(0).getName());&#125; 删 delete(T entity)：从数据库中删除给定的实体 deleteAll() ：删除数据库中全部数据 deleteByKey(K key)：从数据库中删除给定Key所对应的实体 deleteByKeyInTx(java.lang.Iterable keys)：使用事务操作删除数据库中给定的所有key所对应的实体 deleteByKeyInTx(K… keys)：使用事务操作删除数据库中给定的所有key所对应的实体 deleteInTx(java.lang.Iterable entities)：使用事务操作删除数据库中给定实体集合中的实体 deleteInTx(T… entities)：使用事务操作删除数据库中给定的实体 12345UserDao userDao = GreenDaoManager.getInstance().getmDaoSession().getUserDao();userDao.deleteByKey(1l); if(userDao.loadAll().size()&gt;0)&#123; text.setText(userDao.loadAll().get(0).getName());&#125; 查 T load(K key)：加载给定主键的实体 java.util.List loadAll() T loadByRowId(long rowId) ：加载某一行并返回该行的实体 12UserDao userDao = GreenDaoManager.getInstance().getmDaoSession().getUserDao();userDao.loadByRowId(1l) 改 update(T entity) ：更新给定的实体 updateInTx(java.lang.Iterable entities) ：使用事务操作，更新给定的实体 updateInTx(T… entities)：使用事务操作，更新给定的实体 123456789UserDao userDao = GreenDaoManager.getInstance().getmDaoSession().getUserDao();User user = userDao.load(1l)if (user != null) &#123; user.setAge(30); userDao.update(user);&#125;if(userDao.loadAll().size()&gt;0)&#123; text.setText(userDao.loadAll().get(0).getAge());&#125; greenDAO支持使用queryBuilder实现更加复杂的查询 queryBuilderQueryBuilder能够让你在不涉及SQL语句的情况下查询实体。1.where：条件查询 参数为逻辑与的关系（AND） 查询姓名是黎明并且年龄&gt;=10的数据1234UserDao userDao = GreenDaoManager.getInstance().getmDaoSession().getUserDao();QueryBuilder qb=userDao.queryBuilder();qb.where(UserDao.Properties.Name.eq(\"黎明\"), UserDao.Properties.Age.ge(10));List&lt;User&gt; list= qb.list(); 关于属性的一些操作 eq：= notEq：&lt;&gt; like:LIKE between：BETWEEN … AND … in：IN (…, …, …) notIn：NOT IN (…, …, …) gt：&gt; lt：&lt; ge：&gt;= le：&lt;= isNull：IS NULL isNotNull：IS NOT NULL 2.whereOr：条件查询 参数为逻辑或的关系（OR） 查询姓名是黎明或者年龄&gt;=10的数据1234UserDao userDao = GreenDaoManager.getInstance().getmDaoSession().getUserDao();QueryBuilder qb=userDao.queryBuilder();qb.whereOr(UserDao.Properties.Name.eq(\"黎明\"), UserDao.Properties.Age.ge(10));List&lt;User&gt; list= qb.list(); 3.or：条件OR在where或者whereOr里面使用4.and：条件AND在where或者whereOr里面使用5.join：连表查询这里我们新建一个Address的表123456@Entitypublic class Address &#123; @Id(autoincrement = true) private Long id; private String name;&#125; 然后我们添加一个ToOne的关系1234567@Entitypublic class User &#123; ... private Long aid; @ToOne(joinProperty = \"aid\") private Address address;&#125; 然后Make Project 自动生成相关代码假设我们Address表中添加如下数据1234AddressDao addressDao=GreenDaoManager.getInstance().getmDaoSession().getAddressDao();addressDao.insert(new Address(null,\"北京\"));addressDao.insert(new Address(null,\"上海\"));addressDao.insert(new Address(null,\"深圳\")); 插入一条用户数据1userDao.insert(new User(null,\"刘生\",18,2));//上海 现在我们便可以进行连表查询了假设我们查询地址是上海的用户123QueryBuilder qb=userDao.queryBuilder();qb.join(Address.class,AddressDao.Properties.Id).where(AddressDao.Properties.Name.eq(\"上海\"));qb.list(); 6.orderAsc：升序7.orderDesc 降序8.limit：返回数据的条目个数9.offset：偏移量，配合limit使用 1234int page=0;UserDao userDao = GreenDaoManager.getInstance().getmDaoSession().getUserDao();QueryBuilder qb=userDao.queryBuilder();List&lt;User&gt; list = qb.offset(page*0).limit(10).list(); QueryQuery类是一个能够执行多次的查询语句还是上面的例子，查询姓名是黎明并且年龄&gt;=10123UserDao userDao = GreenDaoManager.getInstance().getmDaoSession().getUserDao();Query query=userDao.queryBuilder().where(UserDao.Properties.Name.eq(\"黎明\").build();List&lt;User&gt; list= qb.list(); 然后我们改成查询姓名是小王的12query.setParameter(0, \"小王\");List&lt;User&gt; list= qb.list(); 使用setParameter便可执行多次查询语句。 最后本期主要介绍的数据的基本操作，下期我们介绍数据集的升级问题。","tags":[{"name":"Android","slug":"Android","permalink":"//dongqing123.cn/tags/Android/"},{"name":"数据库","slug":"数据库","permalink":"//dongqing123.cn/tags/数据库/"},{"name":"greenDAO","slug":"greenDAO","permalink":"//dongqing123.cn/tags/greenDAO/"}]},{"title":"数据库greenDAO的使用（一）","date":"2017-03-08T09:34:42.000Z","path":"2017/03/08/数据库greenDAO的使用-一/","text":"之前我们介绍了数据库realm的使用，今天我们介绍一款ORM框架greenDAO的使用。首先到查看github地址https://github.com/greenrobot/greenDAO ，根据文档做相应的配置。Gradle 插件配置12345greendao &#123; schemaVersion 1 daoPackage 'com.greendao.gen' targetGenDir 'src/main/java'&#125; schemaVersion： 数据库schema版本，也可以理解为数据库版本号 daoPackage：设置DaoMaster 、DaoSession、Dao包名 targetGenDir：设置DaoMaster 、DaoSession、Dao目录 targetGenDirTest：设置生成单元测试目录 generateTests：设置自动生成单元测试用例 实体@Entity注解123456789101112@Entity( schema = \"myschema\", active = true, nameInDb = \"AWESOME_USERS\", indexes = &#123; @Index(value = \"name DESC\", unique = true) &#125;, createInDb = false)public class User &#123; ...&#125; schema：告知GreenDao当前实体属于哪个schema active：标记一个实体处于活动状态，活动实体有更新、删除和刷新方法 ameInDb：在数据中使用的别名，默认使用的是实体的类名 indexes：定义索引，可以跨越多个列 createInDb：是否创建表,如果是有多个实体都关联这个表，可以把多余的实体里面设置为false避免重复创建（默认是true） 基础属性注解12345678910111213141516171819202122232425262728293031323334@Entitypublic class User &#123; @Id(autoincrement = true) private Long id; private String name; @Transient private String sex; @Generated(hash = 873297011) public User(Long id, String name) &#123; this.id = id; this.name = name; &#125; @Generated(hash = 586692638) public User() &#123; &#125; public Long getId() &#123; return this.id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return this.sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125;&#125; @Entity：用于标识这是一个需要Greendao帮我们生成代码的bean @Id：标明主键，可以通过@Id(autoincrement = true)设置自增长 @Property：用于设置属性在数据库中的列名（默认不写就是保持一致） @NotNull ：非空 @Transient：标识这个字段是自定义的不会创建到数据库表里 @Convert：指定自定义类型(@linkPropertyConverter) @Generated：greenDAO运行所产生的构造函数或者方法，被此标注的代码可以变更或者下次运行时清除 @Keep：注解的代码段在GreenDao下次运行时保持不变 OrderBy：指定排序 索引注解 @Index：使用@Index作为一个属性来创建一个索引，通过name设置索引别名，也可以通过unique给索引添加约束 @Unique：向数据库列添加了一个唯一的约束 关系注解12345678910111213@Entitypublic class User &#123; @Id private Long id; @ToMany(referencedJoinProperty = \"ownerId\") private List&lt;Site&gt; ownedSites;&#125; @Entitypublic class Site &#123; @Id private Long id; private long ownerId;&#125; 12345678910111213141516@Entitypublic class User &#123; @Id private Long id; @Unique private String authorTag; @ToMany(joinProperties = &#123; @JoinProperty(name = \"authorTag\", referencedName = \"ownerTag\") &#125;) private List&lt;Site&gt; ownedSites;&#125; @Entitypublic class Site &#123; @Id private Long id; @NotNull private String ownerTag;&#125; 123456789101112131415161718192021222324@Entitypublic class Site &#123; @Id private Long id; @ToMany @JoinEntity( entity = JoinSiteToUser.class, sourceProperty = \"siteId\", targetProperty = \"userId\" ) private List&lt;User&gt; authors;&#125; @Entitypublic class JoinSiteToUser &#123; @Id private Long id; private Long siteId; private Long userId;&#125; @Entitypublic class User &#123; @Id private Long id;&#125; @ToOne：一对一 @ToMany ：一对多 JoinEntity：定义表连接关系，如果你在做多对多的关系，可以给目标属性添加这个额外的注解 @JoinProperty：定义名称和引用名称属性关系 本期主要介绍greenDAO的注解相关的介绍，下期介绍数据的操作。","tags":[{"name":"Android","slug":"Android","permalink":"//dongqing123.cn/tags/Android/"},{"name":"数据库","slug":"数据库","permalink":"//dongqing123.cn/tags/数据库/"},{"name":"greenDAO","slug":"greenDAO","permalink":"//dongqing123.cn/tags/greenDAO/"}]},{"title":"Activity、Fragment生命周期","date":"2017-02-27T02:14:31.000Z","path":"2017/02/27/Activity、Fragment生命周期/","text":"Activity生命周期 Fragment生命周期 Activity与Fragment对比 横竖屏生命周期横竖屏切换","tags":[{"name":"activity","slug":"activity","permalink":"//dongqing123.cn/tags/activity/"},{"name":"fragment","slug":"fragment","permalink":"//dongqing123.cn/tags/fragment/"},{"name":"生命周期","slug":"生命周期","permalink":"//dongqing123.cn/tags/生命周期/"}]},{"title":"drakeet MultiType的使用","date":"2017-02-13T07:57:10.000Z","path":"2017/02/13/drakeet-MultiType的使用/","text":"我们在日常使用recyclerview时，总会遇到各种比较复杂的布局，这时候仅仅是一个简单的item已经不能满足我们的要求，如何实现这些呢，目前主要有三种方式1、嵌套2、addView3、使用type这些方法虽然都可以实现我们想要的布局，但缺点都是比较明显的，耦合度特别大，每当我们需要修改时，不得不修改Adapter的内容，因此今天我们要谈一款能优雅、解耦的开源库来实现复杂的布局。drakeet的MultiType就是为这而生的，其简单，高效，解耦的实现这些复杂的布局，地址传送门 MultiType。MultiType的作者也详细的介绍了该库的如何使用Effective-MultiType ,今天我们就针对具体的需求，如何使用该库。很早之前就订阅了代码家的gank.io，一直很感谢大牛的无私奉献，每日为我们推送技术文章。因此最近使用代码家的api，开发了一款gank的客户端（应用宝：干货Gank），其中每日gank的数据是比较多的，涉及到Android、iOS、前端等多个领域。如返回的数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&#123; \"category\": [ \"休息视频\", \"瞎推荐\", \"iOS\", \"Android\", \"福利\" ], \"error\": false, \"results\": &#123; \"Android\": [ &#123; \"_id\": \"589d2bcd421aa9270bc7332c\", \"createdAt\": \"2017-02-10T10:56:13.792Z\", \"desc\": \"Android 信用卡提交效果。\", \"images\": [ \"http://img.gank.io/0df0d67f-6d39-4880-9a44-b2531ccb3a75\" ], \"publishedAt\": \"2017-02-10T11:38:22.122Z\", \"source\": \"chrome\", \"type\": \"Android\", \"url\": \"https://github.com/adonixis/android-sumbit-credit-card-flow\", \"used\": true, \"who\": \"代码家\" &#125;, &#123; \"_id\": \"589d2bed421aa92710db9613\", \"createdAt\": \"2017-02-10T10:56:45.622Z\", \"desc\": \"简洁优雅的网络状态提示。\", \"images\": [ \"http://img.gank.io/93211cbf-d4af-4bc4-ba76-621dfb1dfe40\" ], \"publishedAt\": \"2017-02-10T11:38:22.122Z\", \"source\": \"chrome\", \"type\": \"Android\", \"url\": \"https://github.com/iammert/StatusView\", \"used\": true, \"who\": \"代码家\" &#125; ], \"iOS\": [ &#123; \"_id\": \"589d2af5421aa9270bc7332b\", \"createdAt\": \"2017-02-10T10:52:37.898Z\", \"desc\": \"Swift 发送邮件 📧\", \"images\": [ \"http://img.gank.io/41577a74-2e4b-4f20-9cee-5f5d3a2a2ce4\" ], \"publishedAt\": \"2017-02-10T11:38:22.122Z\", \"source\": \"chrome\", \"type\": \"iOS\", \"url\": \"https://github.com/onevcat/Hedwig\", \"used\": true, \"who\": \"代码家\" &#125;, &#123; \"_id\": \"589d2b9f421aa92710db9612\", \"createdAt\": \"2017-02-10T10:55:27.144Z\", \"desc\": \"弹出一个醒目而优雅的通知框。\", \"publishedAt\": \"2017-02-10T11:38:22.122Z\", \"source\": \"chrome\", \"type\": \"iOS\", \"url\": \"https://github.com/candostdagdeviren/CDAlertView\", \"used\": true, \"who\": \"代码家\" &#125; ], \"休息视频\": [ &#123; \"_id\": \"58974706421aa970bed462c2\", \"createdAt\": \"2017-02-05T23:38:46.879Z\", \"desc\": \"不要给我讲理，我就是道理...也是说出了万千女生的心声...哈哈哈~真理都在女人嘴里，无法反驳...[笑cry][笑cry]\", \"publishedAt\": \"2017-02-10T11:38:22.122Z\", \"source\": \"chrome\", \"type\": \"休息视频\", \"url\": \"http://weibo.com/tv/v/cf39d9a371f7329cb7736bd1b16293de?fid=1034:cf39d9a371f7329cb7736bd1b16293de\", \"used\": true, \"who\": \"lxxself\" &#125; ], \"瞎推荐\": [ &#123; \"_id\": \"589c0e76421aa92dbe257232\", \"createdAt\": \"2017-02-09T14:38:46.687Z\", \"desc\": \"阿里巴巴Java开发手册\", \"publishedAt\": \"2017-02-10T11:38:22.122Z\", \"source\": \"chrome\", \"type\": \"瞎推荐\", \"url\": \"http://deadlion.cn/2017/02/05/Alibaba-Java-Code-Style.html\", \"used\": true, \"who\": \"wuzheng\" &#125; ], \"福利\": [ &#123; \"_id\": \"589d31a2421aa9270bc7332e\", \"createdAt\": \"2017-02-10T11:21:06.747Z\", \"desc\": \"2-10\", \"publishedAt\": \"2017-02-10T11:38:22.122Z\", \"source\": \"chrome\", \"type\": \"福利\", \"url\": \"http://7xi8d6.com1.z0.glb.clouddn.com/2017-02-10-16465759_171779496648995_128281069584646144_n.jpg\", \"used\": true, \"who\": \"代码家\" &#125; ] &#125;&#125; 我们想要每日gank的页面简单好看 ，能区分类别。如下图 从图中可以看我我们需要三种类别，分别是最上面的福利图片，技术文章的类别和文章。 如何使用通过学习MultiType，必然需要三个ItemViewProvider，对应三种布局。1.顶部的图片2.分类标题3.文章 顶部图片的代码123456789101112131415161718192021222324252627public class FuliViewProvider extends ItemViewProvider&lt;FuliBean, FuliViewProvider.ViewHolder&gt; &#123; @NonNull @Override protected ViewHolder onCreateViewHolder(@NonNull LayoutInflater inflater, @NonNull ViewGroup parent) &#123; View root = inflater.inflate(R.layout.item_fuli, parent, false); return new ViewHolder(root); &#125; @Override protected void onBindViewHolder(@NonNull ViewHolder holder, @NonNull FuliBean fuliBean) &#123; Glide.with(holder.image.getContext()).load(fuliBean.getUrl()).crossFade().centerCrop().into(holder.image); SimpleDateFormat df = new SimpleDateFormat(\"yyyy/MM/dd\"); holder.time.setText(df.format(fuliBean.getPublishedAt())); &#125; static class ViewHolder extends RecyclerView.ViewHolder &#123; private ImageView image; private TextView time; ViewHolder(View itemView) &#123; super(itemView); image = (ImageView) itemView.findViewById(R.id.image); time = (TextView) itemView.findViewById(R.id.text); &#125; &#125;&#125;` 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"150dp\"&gt; &lt;ImageView android:id=\"@+id/image\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:adjustViewBounds=\"true\" /&gt; &lt;TextView android:id=\"@+id/text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom|right\" android:layout_marginBottom=\"15dp\" android:layout_marginRight=\"15dp\" android:textColor=\"#00ff00\" android:textSize=\"20sp\" /&gt;&lt;/FrameLayout&gt; 分类标题12345678910111213141516171819202122public class HeaderViewProvider extends ItemViewProvider&lt;HeaderBean, HeaderViewProvider.ViewHolder&gt; &#123; @NonNull @Override protected ViewHolder onCreateViewHolder(@NonNull LayoutInflater inflater, @NonNull ViewGroup parent) &#123; View root = inflater.inflate(R.layout.item_header, parent, false); return new ViewHolder(root); &#125; @Override protected void onBindViewHolder(@NonNull ViewHolder holder, @NonNull HeaderBean headerBean) &#123; holder.content.setText(headerBean.getTitle()); &#125; static class ViewHolder extends RecyclerView.ViewHolder &#123; private TextView content; ViewHolder(View itemView) &#123; super(itemView); content = (TextView) itemView.findViewById(R.id.text); &#125; &#125;&#125; 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;TextView android:id=\"@+id/text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_margin=\"10dp\" android:textColor=\"#000\" android:textSize=\"18sp\" android:textStyle=\"bold\" /&gt;&lt;/LinearLayout&gt; 技术文章12345678910111213141516171819202122232425262728293031public class ImageViewProvider extends ItemViewProvider&lt;ImgDataBean,ImageViewProvider.ViewHolder&gt; &#123; @NonNull @Override protected ViewHolder onCreateViewHolder(@NonNull LayoutInflater inflater, @NonNull ViewGroup parent) &#123; View root = inflater.inflate(R.layout.item_image, parent, false); return new ViewHolder(root); &#125; @Override protected void onBindViewHolder(@NonNull ViewHolder holder, @NonNull ImgDataBean dataBean) &#123; holder.content.setText(dataBean.getDesc()); if(dataBean.getImages()!=null&amp;&amp;dataBean.getImages().size()&gt;0)&#123; holder.image.setVisibility(View.VISIBLE); Glide.with(holder.image.getContext()).load(dataBean.getImages().get(0)).crossFade().centerCrop().into(holder.image); &#125;else&#123; holder.image.setVisibility(View.GONE); &#125; &#125; static class ViewHolder extends RecyclerView.ViewHolder &#123; private TextView content; private ImageView image; ViewHolder(View itemView) &#123; super(itemView); content = (TextView) itemView.findViewById(R.id.text); image = (ImageView) itemView.findViewById(R.id.image); &#125; &#125;&#125; 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_margin=\"10dp\" android:orientation=\"vertical\"&gt; &lt;TextView android:id=\"@+id/text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; &lt;ImageView android:id=\"@+id/image\" android:layout_width=\"100dp\" android:layout_height=\"100dp\" android:layout_gravity=\"center_horizontal\" android:layout_marginTop=\"10dp\" android:src=\"@mipmap/ic_launcher\" /&gt;&lt;/LinearLayout&gt; 这样我们在Activity或其他地方，注册register这些都可以了。具体代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ... GankData gank = new Gson().fromJson(Data.Gank, GankData.class); recyclerView = (RecyclerView) findViewById(R.id.recyclerView); LinearLayoutManager layoutManager = new LinearLayoutManager(this); layoutManager.setOrientation(LinearLayoutManager.VERTICAL); recyclerView.setLayoutManager(layoutManager); items = new Items(); adapter = new MultiTypeAdapter(); adapter.register(FuliBean.class, new FuliViewProvider()); adapter.register(HeaderBean.class, new HeaderViewProvider()); adapter.register(ImgDataBean.class, new ImageViewProvider()); recyclerView.setAdapter(adapter); Gson gson = new Gson(); if (gank.getResults() != null) &#123; if (gank.getResults().get福利() != null &amp;&amp; gank.getResults().get福利().size() &gt; 0) &#123; ImgDataBean img = gank.getResults().get福利().get(0); FuliBean bean = gson.fromJson(gson.toJson(img), FuliBean.class); items.add(bean); &#125; if (gank.getResults().getAndroid() != null &amp;&amp; gank.getResults().getAndroid().size() &gt; 0) &#123; items.add(new HeaderBean(\"Android\")); items.addAll(gank.getResults().getAndroid()); &#125; if (gank.getResults().getiOS() != null &amp;&amp; gank.getResults().getiOS().size() &gt; 0) &#123; items.add(new HeaderBean(\"iOS\")); items.addAll(gank.getResults().getiOS()); &#125; if (gank.getResults().get前端() != null &amp;&amp; gank.getResults().get前端().size() &gt; 0) &#123; items.add(new HeaderBean(\"前端\")); items.addAll(gank.getResults().get前端()); &#125; if (gank.getResults().get瞎推荐() != null &amp;&amp; gank.getResults().get瞎推荐().size() &gt; 0) &#123; items.add(new HeaderBean(\"瞎推荐\")); items.addAll(gank.getResults().get瞎推荐()); &#125; if (gank.getResults().get拓展资源() != null &amp;&amp; gank.getResults().get拓展资源().size() &gt; 0) &#123; items.add(new HeaderBean(\"拓展资源\")); items.addAll(gank.getResults().get拓展资源()); &#125; if (gank.getResults().get休息视频() != null &amp;&amp; gank.getResults().get休息视频().size() &gt; 0) &#123; items.add(new HeaderBean(\"休息视频\")); items.addAll(gank.getResults().get休息视频()); &#125; &#125; adapter.setItems(items); adapter.notifyDataSetChanged();&#125; 如果需要需改，我们只需要修改对应的ItemViewProvider，或添加ItemViewProvider，是不是很方便呢。当然我们还可以结合cardview实现圆角的边距，让布局更加的优雅。 具体如何实现，可看我的github地址MultiTypeDemo。 最后本文通过gank的每日数据来具体的使用MultiType，本文仅仅只是粗略的讲解了使用的方式，让读者明白MultiType的优点。更多的使用请参考drakeet的讲解。","tags":[{"name":"Android","slug":"Android","permalink":"//dongqing123.cn/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"//dongqing123.cn/tags/RecyclerView/"},{"name":"MultiType","slug":"MultiType","permalink":"//dongqing123.cn/tags/MultiType/"}]},{"title":"自定义Behavior（一）","date":"2017-02-09T03:21:56.000Z","path":"2017/02/09/自定义Behavior（一）/","text":"在android design库的使用（二）一文中我们使用了FloatingActionButton,它是android design给我们带来的一个悬浮button，我们可以通过它做许多许多的事情。Behavior是CoordinatorLayout带来的一个以非侵入的为View添加动态的依赖布局，和处理父布局(CoordinatorLayout)滑动手势的一系列回调，比如我们可以通过它实现动态隐藏于显示FloatingActionButton，实现类似于一个返回顶部的提示悬浮按钮。 如何实现首先我们查看CoordinatorLayout中抽象类Behavior，与滚动有关的方法123456789101112131415161718192021222324252627282930313233@Overridepublic boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, FloatingActionButton child, View directTargetChild, View target, int nestedScrollAxes) &#123; return super.onStartNestedScroll(coordinatorLayout, child, directTargetChild, target, nestedScrollAxes);&#125;@Overridepublic void onNestedScrollAccepted(CoordinatorLayout coordinatorLayout, FloatingActionButton child, View directTargetChild, View target, int nestedScrollAxes) &#123; super.onNestedScrollAccepted(coordinatorLayout, child, directTargetChild, target, nestedScrollAxes);&#125;@Overridepublic void onNestedScroll(CoordinatorLayout coordinatorLayout, FloatingActionButton child, View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) &#123; super.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed);&#125;@Overridepublic void onNestedPreScroll(CoordinatorLayout coordinatorLayout, FloatingActionButton child, View target, int dx, int dy, int[] consumed) &#123; super.onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed);&#125;@Overridepublic void onStopNestedScroll(CoordinatorLayout coordinatorLayout, FloatingActionButton child, View target) &#123; super.onStopNestedScroll(coordinatorLayout, child, target);&#125;@Overridepublic boolean onNestedFling(CoordinatorLayout coordinatorLayout, FloatingActionButton child, View target, float velocityX, float velocityY, boolean consumed) &#123; return super.onNestedFling(coordinatorLayout, child, target, velocityX, velocityY, consumed);&#125;@Overridepublic boolean onNestedPreFling(CoordinatorLayout coordinatorLayout, FloatingActionButton child, View target, float velocityX, float velocityY) &#123; return super.onNestedPreFling(coordinatorLayout, child, target, velocityX, velocityY);&#125; 因此我们新建类继承FloatingActionButton.Behavior（这里我们直接继承FloatingActionButton，这样就可以利用已实现的方法）,重写开始滚动onStartNestedScroll与滚动onNestedScroll方法。1234567891011public class FaBtnBehavior extends FloatingActionButton.Behavior&#123; @Override public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, FloatingActionButton child, View directTargetChild, View target, int nestedScrollAxes) &#123; return super.onStartNestedScroll(coordinatorLayout, child, directTargetChild, target, nestedScrollAxes); &#125; @Override public void onNestedScroll(CoordinatorLayout coordinatorLayout, FloatingActionButton child, View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) &#123; super.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed); &#125;&#125; 这里比方我们要实现上滑隐藏，下滑显示FloatingActionButton1234567@Overridepublic boolean onStartNestedScroll(final CoordinatorLayout coordinatorLayout, final FloatingActionButton child, final View directTargetChild, final View target, final int nestedScrollAxes) &#123; // Ensure we react to vertical scrolling return nestedScrollAxes == ViewCompat.SCROLL_AXIS_VERTICAL || super.onStartNestedScroll(coordinatorLayout, child, directTargetChild, target, nestedScrollAxes);&#125; 12345678910111213@Overridepublic void onNestedScroll(final CoordinatorLayout coordinatorLayout, final FloatingActionButton child, final View target, final int dxConsumed, final int dyConsumed, final int dxUnconsumed, final int dyUnconsumed) &#123; super.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed); if (dyConsumed &gt; 0 &amp;&amp; child.getVisibility() == View.VISIBLE) &#123; // User scrolled down and the FAB is currently visible -&gt; hide the FAB child.hide(); &#125; else if (dyConsumed &lt; 0 &amp;&amp; child.getVisibility() != View.VISIBLE) &#123; // User scrolled up and the FAB is currently not visible -&gt; show the FAB child.show(); &#125;&#125; 这里我们只是简单的显示与隐藏，当然你也可以渐变的隐藏与显示，实现更好看的交互效果。下面我们就实现加上动画的交互效果onStartNestedScroll 内容与上面一样onNestedScroll 中把我们添加动画1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private static final Interpolator INTERPOLATOR = new FastOutSlowInInterpolator();private boolean mIsAnimatingOut = false;@Overridepublic void onNestedScroll(final CoordinatorLayout coordinatorLayout, final FloatingActionButton child, final View target, final int dxConsumed, final int dyConsumed, final int dxUnconsumed, final int dyUnconsumed) &#123; super.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed); if (dyConsumed &gt; 0 &amp;&amp; !this.mIsAnimatingOut &amp;&amp; child.getVisibility() == View.VISIBLE) &#123; // User scrolled down and the FAB is currently visible -&gt; hide the FAB animateOut(child); &#125; else if (dyConsumed &lt; 0 &amp;&amp; child.getVisibility() != View.VISIBLE) &#123; // User scrolled up and the FAB is currently not visible -&gt; show the FAB animateIn(child); &#125;&#125;// Same animation that FloatingActionButton.Behavior uses to hide the FAB when the AppBarLayout exitsprivate void animateOut(final FloatingActionButton button) &#123; if (Build.VERSION.SDK_INT &gt;= 14) &#123; ViewCompat.animate(button).translationY(button.getHeight() + getMarginBottom(button)).setInterpolator(INTERPOLATOR).withLayer() .setListener(new ViewPropertyAnimatorListener() &#123; public void onAnimationStart(View view) &#123; ScrollAwareFABBehavior.this.mIsAnimatingOut = true; &#125; public void onAnimationCancel(View view) &#123; ScrollAwareFABBehavior.this.mIsAnimatingOut = false; &#125; public void onAnimationEnd(View view) &#123; ScrollAwareFABBehavior.this.mIsAnimatingOut = false; view.setVisibility(View.GONE); &#125; &#125;).start(); &#125; else &#123; &#125;&#125;// Same animation that FloatingActionButton.Behavior uses to show the FAB when the AppBarLayout entersprivate void animateIn(FloatingActionButton button) &#123; button.setVisibility(View.VISIBLE); if (Build.VERSION.SDK_INT &gt;= 14) &#123; ViewCompat.animate(button).translationY(0) .setInterpolator(INTERPOLATOR).withLayer().setListener(null) .start(); &#125; else &#123; &#125;&#125;private int getMarginBottom(View v) &#123; int marginBottom = 0; final ViewGroup.LayoutParams layoutParams = v.getLayoutParams(); if (layoutParams instanceof ViewGroup.MarginLayoutParams) &#123; marginBottom = ((ViewGroup.MarginLayoutParams) layoutParams).bottomMargin; &#125; return marginBottom;&#125; 代码都是基本的插值动画，实现起来不难，不要忘记在layout中给FloatingActionButton添加app:layout_behavior“自定义Behavior的路径”。 最后本文主要介绍Behavior的使用，通过自实现FloatingActionButton的Behavior实现滚动式他的动画交互，下一篇自定义Behavior（二）我们会更深入讲解Behavior，实现任意View的Behavior，达到我们想要的交互效果。","tags":[{"name":"Android","slug":"Android","permalink":"//dongqing123.cn/tags/Android/"},{"name":"Behavior","slug":"Behavior","permalink":"//dongqing123.cn/tags/Behavior/"}]},{"title":"android 7.1  新特性shortcuts","date":"2017-02-07T07:25:52.000Z","path":"2017/02/07/android-7-1-新特性shortcuts/","text":"2016年12月，google再次更新了android的版本，发布了android7.1的正式版，a7.0给我们带来了分屏等功能，那么7.1又给我们带来了哪些功能呢app shortcuts 应用的快捷操作，类似于iOS的 3D Touch，android通过长按桌面快捷方式弹出一些快捷操作，是不是感觉很高大上呢？但是这种操作需要7.1与手机桌面的支持。可惜的是国内各大rom还没有适配android7.1，大多数还是基于6.0的版本，更有5.0、4.4这个被放弃适配的手机，miui一直被嘲笑万年4.4，flyme 千年5.0等等。不过目前有小米、联想、华为等厂商给部分手机升级了内核，适配了android7.0，不过都是新款旗舰，老旗舰真是彻底放弃了呢笔者虽说不是手机Geek，手上zuk z2升级了7.0，nexus5通过论坛升级到CM14.1 android 7.1.1的版本，都无法进行shortcuts的操作😂，于是笔者下载了一款体验桌面Nova Launcher 可以发现百度并没有适配7.1😂（Nova Launcher会默认显示4个操作，编辑、移除、应用信息、卸载），到时印象笔记给了4个shortcuts（最后为Nova Launcher默认显示），后面一个为我们的Demo。那么如何适配shortcuts呢App Shortcut可以分为两种不同的类型： Static Shortcuts（静态快捷方式） 和 Dynamic Shortcuts（动态快捷方式）。 Static Shortcuts在打包到apk的资源文件中定义，所以，直到下一次更新版本时才能改变静态快捷方式的详细说明。创建Static Shortcuts分为以下几步 在manifest配置文件中找到android.intent.category.LAUNCHER 的Activity 添加标签，引用shortcuts资源文件 12345678910&lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=\"android.app.shortcuts\" android:resource=\"@xml/shortcuts\" /&gt;&lt;/activity&gt; res创建资源文件res/xml/shortcuts.xml 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shortcuts xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;shortcut android:enabled=\"true\" android:icon=\"@drawable/ic_search_black_24dp\" android:shortcutDisabledMessage=\"@string/static_shortcut_disabled_message\" android:shortcutId=\"static\" android:shortcutLongLabel=\"@string/static_shortcut_long_label_1\" android:shortcutShortLabel=\"@string/static_shortcut_short_label_1\"&gt; &lt;intent android:action=\"android.intent.action.VIEW\" android:targetClass=\"com.jsqix.dongqing.appshortcuts.StaticShortcutActivity\" android:targetPackage=\"com.jsqix.dongqing.appshortcuts\" /&gt; &lt;/shortcut&gt; &lt;shortcut android:enabled=\"true\" android:icon=\"@drawable/ic_android_black_24dp\" android:shortcutDisabledMessage=\"@string/static_shortcut_disabled_message\" android:shortcutId=\"static_2\" android:shortcutLongLabel=\"@string/static_shortcut_long_label_2\" android:shortcutShortLabel=\"@string/static_shortcut_short_label_2\"&gt; &lt;intent android:action=\"android.intent.action.MAIN\" android:targetClass=\"com.jsqix.dongqing.appshortcuts.MainActivity\" android:targetPackage=\"com.jsqix.dongqing.appshortcuts\" /&gt; &lt;intent android:action=\"android.intent.action.VIEW\" android:targetClass=\"com.jsqix.dongqing.appshortcuts.StaticShortcutActivity\" android:targetPackage=\"com.jsqix.dongqing.appshortcuts\" /&gt; &lt;/shortcut&gt;&lt;/shortcuts&gt; shortcut下标签的含义： enabledshortcut是否可用 icon显示在左边的图标，可用使用Vector drawable shortcutDisabledMessageshortcut不可用时，仍然出现在快捷中，但显示为灰色，点击时弹出此内容的toast shortcutLongLabel启动器有足够多的空间时，会显示这个标签所定义的内容 shortcutShortLabelshortcut的简要说明，是必需字段。当shortcut被添加到桌面上时，显示的也是这个字段 intentshortcut关联的一个或者多个intent，当用户点击shortcut时被打开 shortcutIdshortcut的唯一标示id，若存在具有相同shortcutId的shortcut，则只显示一个 这样静态shortcuts就定义成功了，运行起来就会出现上面图片中的效果，其中点击搜索的shortcut，进入StaticShortcutActivity，返回时回到桌面，点击android的shortcut，进入StaticShortcutActivity，返回时回到MainActivity Dynamic Shortcuts通过ShortcutManager API在运行时发布，在运行时，应用可以发布，升级和移除快捷方式。 发布使用setDynamicShortcuts()重新定义整个动态快捷方式列表，或者是使用addDynamicShortcuts()向已存在的动态快捷方式列表中添加快捷方式。 更新使用updateShortcuts()方法。 移除使用removeDynamicShortcuts()方法移除特定动态快捷方式或者使用removeAllDynamicShortcuts()移除所有动态快捷方式。下面我们使用api实现静态shortcuts的两个情况在MainActivity中创建动态shortcuts12345678910111213141516171819202122232425@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; ... createShortcuts();&#125;@TargetApi(25)private void createShortcuts() &#123; ShortcutManager shortcutManager = getSystemService(ShortcutManager.class); ShortcutInfo shortcutInfo = new ShortcutInfo.Builder(this, \"dynamic\") .setShortLabel(\"拍照\") .setLongLabel(\"拍照\") .setIcon(Icon.createWithResource(this, R.drawable.ic_camera_alt_black_24dp)) //.setIntent(new Intent(Intent.ACTION_VIEW, Uri.EMPTY,this,DynamicShortcutActivity.class)) .setIntents( // this dynamic shortcut set up a back stack using Intents, when pressing back, will go to MainActivity // the last Intent is what the shortcut really opened new Intent[]&#123; new Intent(Intent.ACTION_MAIN, Uri.EMPTY, this, MainActivity.class).setFlags(Intent. FLAG_ACTIVITY_CLEAR_TASK), new Intent(DynamicShortcutActivity.ACTION_OPEN_DYNAMIC) // intent's action must be set &#125;) .build(); shortcutManager.setDynamicShortcuts(Collections.singletonList(shortcutInfo));&#125; 创建空的DynamicShortcutActivity，在manifest清单中123456&lt;activity android:name=\".DynamicShortcutActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.jsqix.dongqing.appshortcuts.OPEN_DYNAMIC_SHORTCUT\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 通过setIntent实现打开shortcuts返回桌面，通过setIntents实现打开shortcuts返回到我们指定的MainActivity注意Shortcuts有个数限制，因此采用动态创建时需要判断最大的限制getMaxShortcutCountPerActivity否则会抛异常 其他 当static shortcut 和 dynamic shortcut一起展示时，我们如何决定其显示的顺序呢？在 ShortcutInfo.Builder 中有一个专门的方法 setRank(int) ,通过设置不同的等级，我们就可以控制动态快捷方式的出现顺序，等级越高，出现在快捷方式列表中的位置就越高。 我们还可以设置动态快捷方式的shortLabel的字体颜色12345678ForegroundColorSpan colorSpan = new ForegroundColorSpan(getResources().getColor(android.R.color.holo_red_dark, getTheme()));String label = \"拍照\";SpannableStringBuilder colouredLabel = new SpannableStringBuilder(label);colouredLabel.setSpan(colorSpan, 0, label.length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE);ShortcutInfo shortcutInfo = new ShortcutInfo.Builder(this, \"dynamic\") .setShortLabel(colouredLabel) .setRank(1) .build(); 原则 为了保持我们的应用和系统应用的快捷方式在视觉上一致性，应该遵守App Shortcuts Design Guidelines 尽管现在的API支持静态和动态总共5个快捷方式，但是为了提高shortcut的视觉效果，建议只添加4个不同的快捷方式 如果可能的话，应该将「short description」的文字长度控制在10个字母以内，将「long discription」的长度限制在25个字母以内 在备份和恢复时，动态shortcuts不应该被保存。 最后以上就是android7.1给我们带来的app shortcuts功能，实现起来也不是非常的难，给人一种高大上的3D Touch效果，还是值得肯定的。就是国内厂家不知何时适配，说不定不用更新内核就添加上该功能呢（flyme5在5.0上实现分屏的功能😌）。","tags":[{"name":"Android","slug":"Android","permalink":"//dongqing123.cn/tags/Android/"},{"name":"shortcuts","slug":"shortcuts","permalink":"//dongqing123.cn/tags/shortcuts/"}]},{"title":"TabLayout+ViewPager","date":"2017-02-06T07:21:37.000Z","path":"2017/02/06/TabLayout-ViewPager/","text":"ViewPage，这个人人不陌生的滑动导航控件，配合Fragment使用实现底部或顶部的导航菜单，网上也有许许多多关于ViewPage的tab的开源代码，在5.0之前用过ViewPagerIndicator、PagerSlidingTabStrip等各种tab指示器的开源库，但是android5.0给我们带来了design库，里面就有我们今天的主角TabLayout。 如何使用TabLayout在使用上是非常简单的12345678910&lt;android.support.design.widget.TabLayout android:id=\"@+id/tabs\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:tabIndicatorColor=\"#ADBE107E\" app:tabMode=\"scrollable\" /&gt;&lt;android.support.v4.view.ViewPager android:id=\"@+id/viewpager\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt; 属性说明 app:tabModetabMode有两个值：fixed和scrollable，表示超过一屏幕时是否可以滚动。fixed表示填充，scrollable表示可以滚动。 app:tabGravitytabGravity有两个值：fill和center，表示tab在未满一屏时的对齐方式。fill表示填充，center表示居中。 app:tabIndicatorColor选中时tab下划线的颜色 app:tabSelectedTextColor选中时tab字体颜色 app:tabTextColor未选中tab字体颜色 java代码部分则是添加adapter与tab绑定12345mTabLayout = (TabLayout) view.findViewById(R.id.tabs);mViewPager = (ViewPager) view.findViewById(R.id.viewpager);TabFragmentAdapter adapter = new TabFragmentAdapter(getSupportFragmentManager(), fragments, titles);mViewPager.setAdapter(adapter);mTabLayout.setupWithViewPager(mViewPager); 简单的一句setupWithViewPager就可以完成ViewPage与TabLayout的联动，TabLayout也提供了addOnTabSelectedListener来监听tab的选中事件12345678910111213141516mTabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123; @Override public void onTabSelected(TabLayout.Tab tab) &#123; &#125; @Override public void onTabUnselected(TabLayout.Tab tab) &#123; &#125; @Override public void onTabReselected(TabLayout.Tab tab) &#123; &#125;&#125;); 是不是非常简单的实现了ViewPage的tab问题呢 最后TabLayout与ViewPage联合很好的解决了指示器的问题，毕竟这是官方的解决方案，一些开源库已经很久没有维护了，而且在使用上是非常简单的。","tags":[{"name":"Android","slug":"Android","permalink":"//dongqing123.cn/tags/Android/"},{"name":"design","slug":"design","permalink":"//dongqing123.cn/tags/design/"},{"name":"TabLayout","slug":"TabLayout","permalink":"//dongqing123.cn/tags/TabLayout/"}]},{"title":"github page +hexo 建立个人blog","date":"2017-02-06T02:19:45.000Z","path":"2017/02/06/github-page-hexo-建立个人blog/","text":"作为一个技术开发人员，博客是记录自己知识的平台，无论是项目中遇到的问题还是自己使用框架、控件等的心得。俗话说好记性不如烂笔头，平时工作或者生活中的大大小小的事记录下来（当然这里不是写纸质日记），总比到时候到处找好。早期程序员都是混各种论坛，写博客就会用第三方的如：CSDN、博客园等，再到后知乎、简书、微信、微博等，最后就是自己搭建博客了。本人作为一个Android程序员对前端网页的知识不是非常了解，一开始要我搭建博客我是拒绝的，虽然我知道github提供了github page这个一个免费的平台。后来是查看了相关的文章才了解到配合hexo，我们再也不用关心网页的主题了，只要关注写博客就可以了，真的是一个非常开心的事呢。 Github Pages首先你必须是万千同性交友网站中的一员，也就是有github的账号，然后我们跟平时一样在github上面创建一个仓库，但是名称就有要求了，必须是username.github.io（username就是你github的账户名），到这里我们就成功了一步。 hexo第二部就是通过hexo建立自己的博客 安装hexo安装教程网上有很多,这里直接给出hexo中文网的文档地址：hexo安装传送门 建网站Hexo安装好了之后，就开始进行建站，这里需要使用终端（笔者是Mac）我们选择一个目录作为我们本地存储地址，然后cd 把目录拖进去回车然后123hexo init yournamecd yournamenpm install 其中yourname为你的文件夹名字可随意取（本文这里是DongQing）。完成之后我们需要我hexo与github关联起来，我们打开DongQing中的_config.yml文件，在文件尾123deploy:type: gitrepo: https://github.com/a741762308/a741762308.github.io.git repo 换成你自己的github page 仓库地址 我们在终端运行hexo s命令如果成功打印Start processing Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.在浏览区中敲入http://localhost:4000/.等待奇迹的发生。 发布刚刚那么激动仅仅只是本地跑起来了，我们要发布到github page才行继续终端123hexo cleanhexo ghexo d 命令详解，第一条是清楚缓存，第二条命令是生成本地发布文件夹，第三条命令才是最后的发布到github pages上。更多请参考Hexo官方命令参考文档 现在我们就可以通过username.github.io来访问自己的博客了，比如笔者的是a741762308.github.io,可以看到hexo的画面了，但是这些还不够，不够漂亮。。。。。。。。。 hexo的主题我们找到自己刚刚的文件夹，可以看到有一个themes目录，里面有个默认的主题landscape，我们觉得这个主题不行，实在是不够美观。hexo也为我们提供了许许多多的主题，列出我比较喜欢的 next yilia yelee hexo-theme-material 大家也可以到hexo主题去选择自己喜欢的，一般都告诉你了详细的配置信息。 域名其实实现上次步骤，博客就基本上完成了，只不过访问地址是username.github.io，给人感觉没有逼格😂😂😂。因此追求极致的我们怎么能给人这么low的域名地址呢。因此我们需要需要购买一个域名，我是在阿里云购买了一个域名，可惜的是本人名字的各种域名已经被注册了😂😂😂，注册成功后我们在域名解析里面添加如下图的解析 其中两个A标签是github的地址，CNAME指向我们博客的地址。然后就是在之前建立的站点目录下的source目录中新建一个CNAME文件 然后编辑它添加我们注册的域名(不用添加http://) 最后我们提交到github（在终端输入hexo d -g命令），然后开始见证奇迹的到来吧，如我的博客 可视化博客编辑现在我们写博客都是用markdown的格式，我们可以写好博客后把.md格式的文件复制到该目录下，然后提交命令。 但是我们都希望有个可视化的编辑器，这样修改与写作起来比较方便，笔者使用的是nihgwu/hexo-hey，根据说明配置好相关信息后终端输入hexo s命令，打开浏览器输入http://localhost:4000/admin/输入用户名hexo,密码hey后就可以看到我们的文章了，这样我们可以直接新建然后开心的写博客了（写好文章发布后，本地能看到，但我们还要提交到github，这样输入域名就可以看到刚刚发布的文章了）。 最后搭建自己的博客是一件刚开始比较新鲜与折腾的事，搭建好后，我们就可以直接用可视化插件在线编辑我们的博客，让开发人员不用再注意网站本身，只需要将写好的md文件复制到各大平台与自己的博客地址。虽然自己的博客可能没人看，但是呢，我们的初衷就不是这个，而是让自己坚持写作，坚持分享自己的技术，给自己作总结。","tags":[{"name":"随笔","slug":"随笔","permalink":"//dongqing123.cn/tags/随笔/"},{"name":"博客","slug":"博客","permalink":"//dongqing123.cn/tags/博客/"}]},{"title":"android design库的使用（二）","date":"2017-02-04T07:20:37.000Z","path":"2017/02/04/android-design库的使用（二）/","text":"我一篇我们介绍了DrawerLayout的使用，通过它我们实现一个侧滑的菜单，也说明了一些菜单中的操作及开源的侧滑菜单库，今天我们讲解伸缩的ViewPage，现实生活中有许多的app比如新闻资讯、阅读、影视等都采用ViewPage作为分页的导航，如哔哩哔哩动画Android端 看效果是不是有点感觉很惊艳，其实实现起来很容易的。首先我们要修改布局app_bar_main.xml12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/main_content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.design.widget.AppBarLayout android:id=\"@+id/appbar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" app:layout_scrollFlags=\"scroll|enterAlways\" app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\" /&gt; &lt;android.support.design.widget.TabLayout android:id=\"@+id/tabs\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:tabIndicatorColor=\"#ADBE107E\" app:tabMode=\"scrollable\" /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/viewpager\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" /&gt; &lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/fab\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom|end\" android:layout_margin=\"10dp\" android:src=\"@android:drawable/ic_dialog_email\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 这里我们使用TabLayout+ViewPager来实现滑动导航，具体使用可移步TabLayout+ViewPager然后是Activity中添加viewpage的适配器和tab绑定12345mTabLayout = (TabLayout) view.findViewById(R.id.tabs);mViewPager = (ViewPager) view.findViewById(R.id.viewpager);TabFragmentAdapter adapter = new TabFragmentAdapter(getSupportFragmentManager(), fragments, titles);mViewPager.setAdapter(adapter);mTabLayout.setupWithViewPager(mViewPager); 这个伸缩的ViewPage就完成了，是不是相当的简单呢？其实实现起来只有2步 将Toolbar、TabLayout写在AppBarLayout中并且Toolbar添加app:layout_scrollFlags=&quot;scroll|enterAlways&quot; 将ViewPager写在CoordinatorLayout中并且添加app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; 这样就实现了滑动时隐藏、显示Toolbar的功能。这里我们就需要介绍一下app:layout_scrollFlags与app:layout_behavior app:layout_scrollFlags ScrollFlags共有五种常量值供AppBarLayout的Children View使用，分别为scroll、enterAlways、enterAlwaysCollapsed、snap、exitUntilCollapsed，下面我们描述一下 scrollChild View 伴随着滚动事件而滚出或滚进屏幕。注意： 如果使用了其他值，必定要使用这个值才能起作用。 如果在这个child View前面的任何其他Child View没有设置这个值，那么这个Child View的设置将失去作用。 enterAlways快速返回模式，其实就是向下滚动时Scrolling View和Child View之间的滚动优先级问题，优先滚动Child View然后滚动Scrolling View。 enterAlwaysCollapsedenterAlways的附加值。这里涉及到Child View的高度和最小高度，向下滚动时，Child View先向下滚动最小高度值，然后Scrolling View开始滚动，到达边界时，Child View再向下滚动，直至显示完全。 snap简单理解，就是Child View滚动比例的一个吸附效果。也就是说，Child View不会存在局部显示的情况，滚动Child View的部分高度，当我们松开手指时，Child View要么向上全部滚出屏幕，要么向下全部滚进屏幕，有点类似ViewPager的左右滑动。 exitUntilCollapsed发生向上滚动事件时，Child View向上滚动退出直至最小高度，然后Scrolling View开始滚动。也就是，Child View不会完全退出屏幕。 app:layout_behaviorBehavior是一系列回调。让你有机会以非侵入的为View添加动态的依赖布局，和处理父布局(CoordinatorLayout)滑动手势的机会。详细见自定义Behavior@string/appbar_scrolling_view_behavior(android.support.design.widget.AppBarLayout$ScrollingViewBehavior)作用是自己放到AppBarLayout的下面。 现在再看这些效果是不是so easy呢？上面介绍的一些layout_scrollFlags与layout_behavior没有详细的介绍，以后会填上这些坑的。","tags":[{"name":"design","slug":"design","permalink":"//dongqing123.cn/tags/design/"},{"name":"android","slug":"android","permalink":"//dongqing123.cn/tags/android/"}]},{"title":"26岁，你该明白","date":"2017-02-04T01:43:42.000Z","path":"2017/02/04/26岁，你该明白/","text":"想学什么就学什么，开始做一件事，永远都不会太晚。 警惕到处给人励志的人，实际上他们是在为自己励志而已，往往自己做不到才需要励志。 看多些书，写多些字，少说些话。 第一眼看上去就讨厌的人，你很难改变对他们的印象。尽可能去远的地方看看，世界还有比你想象中更好的地方。 公司永远都不是自己的家，如果有个老板说公司就是家，说用家庭式管理来这个公司，尽快离开这个公司。 不要借钱给朋友，否则你会失去这个朋友。如果一定要借，救急不救穷。 工作同事要求助，首先要判断自己是不是一定要做，其次要问他懂不懂，如果他不懂，一定要教，教三次后他还是不会，就永远教不会了，你也不必再教了，他一般也不会在找你了。 胖子的自制力都比较差。 重复旧的做法，只会得到旧的结果。 不要回头，向前走，工作如此，爱情如此。 安慰失败或者做错事的人，可以这么说：动机和情绪总不会有错，只不过行为没有效果而已。 奥卡姆剃刀定理：如无需要，切勿增加实体。 断舍离：任何物品都会有用处的，判断自己需不需要，如果不需要，果断地扔掉。 经常去去展览馆，不能保证你能马上提高艺术品位，不过能让你有个好心情。 找个价值观一致的伴侣，会省掉很多争吵和磨合的时间，然后去做各自喜欢的事情。 和伴侣吵架，赢了没有用，要看效果。 不要相信自己和别人有什么不同，励志的话诸如you are Special，you are Unique都是真的，但是接受自己是个普通人事实更重要。 大多数成功的人会说自己是幸运而已，努力，应该是一种常有的状态。 试错法是人生的好方法，用得越多，效果越好，年龄一大，成本越大。 与其烦恼，不如思考。人的一切痛苦，本质是都是对自己无能的愤怒。 任何事情，你知道了不去做等于不知道。 孤独是人生的重要伴侣，没有人能够陪伴你到最后，要和自己好好相处。 在你面前说你坏话的人都是关心希望你好你的人，在你背后说的坏话的，也不要介意，不是每个人都喜欢你的，接受这个事实，再做好自己就好。 打造人脉不如打造自己。如果你是一个优秀、有价值的人，那么就会有很多另外优秀、有价值的人为你提供帮助。 解决任何问题的第一步，是要承认问题的存在。First step in solving any problem is recognizing there is one. 不要去追求自由，自由是外界给的，要追独立。","tags":[{"name":"随笔","slug":"随笔","permalink":"//dongqing123.cn/tags/随笔/"}]},{"title":"android design库的使用（一）","date":"2017-01-24T08:05:26.000Z","path":"2017/01/24/android-design库的使用（一）/","text":"android5.0带来的Material Design是非常惊艳的，为了能让这个的设计支持低版本的版本，google提供了design库。今天我们的主角是android的抽屉菜单DrawerLayout及配套使用的一些控件。 最简单的例子就是用Android Studio自带的功能,我们新建一个Activity在模本中选择Navigation drawer Activity 然后finish，这样抽屉菜单就生成了，然后你会看到一个activity与4个layout。我们先看一下效果 效果还不错吧，现在我们来看看布局 activity_main.xml12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/drawer_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" tools:openDrawer=\"start\"&gt; &lt;include layout=\"@layout/app_bar_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; &lt;android.support.design.widget.NavigationView android:id=\"@+id/nav_view\" android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:layout_gravity=\"start\" android:fitsSystemWindows=\"true\" app:headerLayout=\"@layout/nav_header_main\" app:menu=\"@menu/activity_main_drawer\" /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; DrawerLayout是抽屉菜单，include是主页的内容，NavigationView是菜单的内容我们来看看主页的内容app_bar_main.xml12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" tools:context=\"com.jsqix.dongqing.demo.MainActivity\"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:theme=\"@style/AppTheme.AppBarOverlay\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"?attr/colorPrimary\" app:popupTheme=\"@style/AppTheme.PopupOverlay\" /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;include layout=\"@layout/content_main\" /&gt; &lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/fab\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom|end\" android:layout_margin=\"@dimen/fab_margin\" app:srcCompat=\"@android:drawable/ic_dialog_email\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 然后是cotent_main.xml12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/content_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" tools:context=\"com.jsqix.dongqing.demo.MainActivity\" tools:showIn=\"@layout/app_bar_main\"&gt;&lt;/RelativeLayout&gt; 最后是nav_header_main.xml1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"@dimen/nav_header_height\" android:background=\"@drawable/side_nav_bar\" android:gravity=\"bottom\" android:orientation=\"vertical\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark\"&gt; &lt;ImageView android:id=\"@+id/imageView\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:paddingTop=\"@dimen/nav_header_vertical_spacing\" app:srcCompat=\"@android:drawable/sym_def_app_icon\" /&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:paddingTop=\"@dimen/nav_header_vertical_spacing\" android:text=\"Android Studio\" android:textAppearance=\"@style/TextAppearance.AppCompat.Body1\" /&gt; &lt;TextView android:id=\"@+id/textView\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"android.studio@android.com\" /&gt;&lt;/LinearLayout&gt; 及menu123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;group android:checkableBehavior=\"single\"&gt; &lt;item android:id=\"@+id/nav_camera\" android:icon=\"@drawable/ic_menu_camera\" android:title=\"Import\" /&gt; &lt;item android:id=\"@+id/nav_gallery\" android:icon=\"@drawable/ic_menu_gallery\" android:title=\"Gallery\" /&gt; &lt;item android:id=\"@+id/nav_slideshow\" android:icon=\"@drawable/ic_menu_slideshow\" android:title=\"Slideshow\" /&gt; &lt;item android:id=\"@+id/nav_manage\" android:icon=\"@drawable/ic_menu_manage\" android:title=\"Tools\" /&gt; &lt;/group&gt; &lt;item android:title=\"Communicate\"&gt; &lt;menu&gt; &lt;item android:id=\"@+id/nav_share\" android:icon=\"@drawable/ic_menu_share\" android:title=\"Share\" /&gt; &lt;item android:id=\"@+id/nav_send\" android:icon=\"@drawable/ic_menu_send\" android:title=\"Send\" /&gt; &lt;/menu&gt; &lt;/item&gt;&lt;/menu&gt; 现在我们来分析一下布局，首先是drawer，里面包含主页与菜单，菜单是通过head与menu来组装，然后主页里面就是CoordinatorLayout包裹的内容，里面AppBarLayout包裹着Toolbar，还有一个content，最后是FloatingActionButton，content就是我们需要写的布局代码。 今天我们就分析NavigationView的使用通过上面布局我们知道NavigationView主要有两个部分组成，head与menu。head是NavigationView的头，一般用来显示头像等，menu就是一些菜单。android:layout_gravity=&quot;start&quot; 代表是左滑菜单，相应的end便是右滑菜单（建议用start代替left，end代替right，这样可以国际化）。我们再来分析菜单布局文件必须使用menu标签作为根节点。除了menu标签外，还有另外两个标签用于设置菜单项和分组，这两个标签是item和group。menu标签没有任何属性，但可以嵌套在item标签中，表示子菜单的形式。不过item标签中不能再嵌入item标签。 item标签的属性 id，这个大家都知道 menuCategory，同种菜单项的种类 orderInCategor，同种类菜单的排列顺序，值越大越靠前 title，标题 titleCondensed，短标题，当title太长时会显示该属性值 icon，图标 alphabeticShortcut，字母快捷键 numericShortcut，数字快捷键 checkable，是否带复选框 checked，复选框的默认选中 visible，可不可见 enable，可不可操作 group标签的属性 menuCategory，菜单组的种类 orderInCategory，菜单组的排序 checkableBehavior，该组所有菜单项上显示的选择组件，all为CheckBox，single为RadioButton，none为正常的菜单项 visible，菜单组是否可见 enable，菜单组是否可操作 这样我们便可以生产菜单menu文件了。 菜单的事件操作 head中必须通过12NavigationView navigationView = (NavigationView) findViewById(R.id.nav_view);View headerView=navigationView.getHeaderView(0); 通过headerView的findViewById找到相应的组件来进行操作。 menu中setNavigationItemSelectedListener来监听123456NavigationView navigationView = (NavigationView) findViewById(R.id.nav_view);navigationView.setNavigationItemSelectedListener(this);@Overridepublic boolean onNavigationItemSelected(MenuItem item) &#123;&#125; 到这里基本上是完成了滑动菜单，但是这还是不够的。NavigationView 默认是随主题的，菜单默认是灰色的，group菜单选中之后默认是colorPrimary的颜色，如果你需要修改,可以通过如下属性 app:itemIconTint，设置图片的颜色 app:itemTextColor，设置字体颜色 app:itemBackground，设置背景颜色 app:itemTextAppearance，设置字体的TextAppearance 如果你的菜单还需要其他什么功能，比如QQ在右下角显示设置，主题等操作，可以在NavigationView中写你想要的布局如123456789101112131415161718192021222324252627282930313233343536373839404142...&lt;android.support.design.widget.NavigationView android:id=\"@+id/nav_view\" android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:layout_gravity=\"start\" android:fitsSystemWindows=\"true\" app:headerLayout=\"@layout/nav_header_main\" app:menu=\"@menu/activity_main_drawer\"&gt; &lt;RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom\" android:paddingBottom=\"15dp\" android:paddingLeft=\"10dp\" android:paddingRight=\"10dp\"&gt; &lt;TextView android:id=\"@+id/btn_set\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:drawableLeft=\"@mipmap/ic_menu_set\" android:drawablePadding=\"5dp\" android:gravity=\"center\" android:text=\"设置\" android:textColor=\"@color/black\" /&gt; &lt;TextView android:id=\"@+id/btn_theme\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentRight=\"true\" android:layout_marginRight=\"20dp\" android:drawableLeft=\"@mipmap/ic_menu_theme\" android:drawablePadding=\"5dp\" android:gravity=\"center\" android:text=\"主题\" android:textColor=\"@color/black\" /&gt; &lt;/RelativeLayout&gt;&lt;/android.support.design.widget.NavigationView&gt;··· 如果这些还不能满足你，可以试试MaterialDrawer功能强大，可定制高，还支持主题切换。","tags":[{"name":"design","slug":"design","permalink":"//dongqing123.cn/tags/design/"},{"name":"android","slug":"android","permalink":"//dongqing123.cn/tags/android/"},{"name":"drawer","slug":"drawer","permalink":"//dongqing123.cn/tags/drawer/"},{"name":"navigationView","slug":"navigationView","permalink":"//dongqing123.cn/tags/navigationView/"}]},{"title":"RecyclerView与CardView的使用","date":"2017-01-23T07:09:18.000Z","path":"2017/01/23/RecyclerView与CardView的使用/","text":"2014年google发布了android5.0的版本，系统使用一种新的Material Design设计风格，也给我们带来了很多新的特性，RecyclerView与CardView就是起新的两个组件。以前我们写列表布局时都是用ListView、GridView等控件，比较繁琐的就是写Adapter了，而且还要对其优化加入viewholder类。现在RecyclerView就可以替代ListView、GridView，而且自带Holder，加上默认的三种布局方式，可以说给开发者带来很大的好处。 如何使用RecyclerView使用上与一般的AdapterView并没有什么区别，我们先在build.gradle中添加RecyclerView与CardView的依赖12345dependencies &#123; compile 'com.android.support:recylerview-v7:25.0.1' compile 'com.android.support:cardview-v7:25.0.1' ...&#125; layout中1234567...&lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recyclerView\" android:layout_width=\"match_parent\" android:overScrollMode=\"never\" android:layout_height=\"match_parent\" /&gt;... 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v7.widget.CardView xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:card=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"5dp\" android:layout_marginLeft=\"10dp\" android:layout_marginRight=\"10dp\" android:layout_marginTop=\"5dp\" card:cardBackgroundColor=\"@android:color/white\" card:cardCornerRadius=\"5dp\" card:cardElevation=\"2dp\" card:cardMaxElevation=\"5dp\"&gt; &lt;!--cardMaxElevation：最大卡片阴影的宽度--&gt; &lt;!--cardElevation:卡片阴影的宽度--&gt; &lt;!--cardBackgroundColor:卡片的背景颜色--&gt; &lt;!--cardCornerRadius ：卡片的圆角半径--&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;ImageView android:id=\"@+id/image\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:src=\"@mipmap/ic_launcher\" /&gt; &lt;TextView android:id=\"@+id/title\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"10dp\" android:text=\"1\" /&gt; &lt;/LinearLayout&gt;&lt;/android.support.v7.widget.CardView&gt; adapter1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class RecyclerAdapter extends RecyclerView.Adapter&lt;RecycleAdapter.MyViewHolder&gt; &#123; private Context context; private List&lt;String&gt; list; private OnItemClickListener onItemClickListener; public void setOnItemClickListener(OnItemClickListener onItemClickListener) &#123; this.onItemClickListener = onItemClickListener; &#125; public RecyclerAdapter(Context context, List&lt;String&gt; list) &#123; this.context = context; this.list = list; &#125; @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(context).inflate(R.layout.item_recycle, parent, false); return new MyViewHolder(view); &#125; @Override public void onBindViewHolder(MyViewHolder holder, final int position) &#123; final String bean = list.get(position); holder.imageView.setImageResource(R.mipmap.ic_launcher); holder.title.setText(bean); holder.itemView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; onItemClickListener.onItemClick(position); &#125; &#125;); &#125; @Override public int getItemCount() &#123; return list.size(); &#125; public class MyViewHolder extends RecyclerView.ViewHolder &#123; private ImageView imageView; private TextView title; public MyViewHolder(View view) &#123; super(view); imageView = (ImageView) view.findViewById(R.id.image); title = (TextView) view.findViewById(R.id.title); &#125; &#125; interface OnItemClickListener &#123; void onItemClick(int position); &#125;&#125; activity或fragment中1234LinearLayoutManager manager = new LinearLayoutManager(mContext, LinearLayoutManager.VERTICAL, false);recyclerView.setLayoutManager(manager);adapter = new RecyclerAdapter(mContext, R.layout.item_recycler, data);recyclerView.setAdapter(adapter); RecylerView使用必须指明LayoutManager，LayoutManager主要有三类 LinearLayoutManager 线性布局，有水平、垂直 GridLayoutManager 网格布局 StaggeredGridLayoutManager 瀑布流布局 通过ItemDecoration可以绘制item之间的间隔 ItemAnimator设置item的增删动画 click或longClick事件不支持，需要自己写 item 布局中使用了卡片布局CardView app:cardBackgroundColor这是设置背景颜色 app:cardCornerRadius这是设置圆角大小 app:cardElevation这是设置z轴的阴影 app:cardMaxElevation这是设置z轴的最大高度值 app:cardUseCompatPadding是否使用CompatPadding app:cardPreventCornerOverlap是否使用PreventCornerOverlap app:contentPadding 设置内容的padding app:contentPaddingLeft 设置内容的左padding app:contentPaddingTop 设置内容的上padding app:contentPaddingRight 设置内容的右padding app:contentPaddingBottom 设置内容的底padding 效果图 github上相关资源 RecyclerViewItemAnimators DividerItemDecoration RecyclerItemDecoration总结recyclerview作为listview、gridview的替代有着许多的优点，基本上可以完全代替，网上也有许多相关recyclerview的教程、自定义的控件、特效等，cardview卡片布局比较简单，但是实用性和效果是非常好的，用来当做背景再合适不过了。","tags":[{"name":"Android","slug":"Android","permalink":"//dongqing123.cn/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"//dongqing123.cn/tags/RecyclerView/"},{"name":"CardView","slug":"CardView","permalink":"//dongqing123.cn/tags/CardView/"}]},{"title":"android 6.0 权限管理","date":"2017-01-17T06:13:11.000Z","path":"2017/01/17/android-6-0-权限管理/","text":"&#8195;&#8195;如果说5.0是android上的里程碑，那么6.0就是对它的完善与升级。6.0从UI上与5.0没有任何区别，依旧坚持了好评的md风格，但不仅仅只是内核的升级而已。6.0首先是删除了apache的httpclient包，让一些网络请求框架需要对6.0进行适配，虽然有补救的方法，但官方删除了，也让okhttp更深入人心。然后就是今天我们重点讨论的权限管理。&#8195;&#8195;6.0以前的app安装时，会默认授予清单文件manifest中的权限，虽然安装时会告知用户有哪些权限，但一般很少有人会在意这一点。于是各种居心叵测的厂家或者开发者往往都是列一堆的权限，做着用户所不知道的事情。从6.0开始，情况就不一样了，一些危险的权限我们不但在写在manifest中，还需要用户授予同意才能使用。可以说扼杀了一部分厂家的利益。那么这些危险的权限有哪些呢?1234567891011121314151617181920212223242526272829303132permission:android.permission.WRITE_CONTACTSpermission:android.permission.GET_ACCOUNTSpermission:android.permission.READ_CONTACTSpermission:android.permission.READ_CALL_LOGpermission:android.permission.READ_PHONE_STATEpermission:android.permission.CALL_PHONEpermission:android.permission.WRITE_CALL_LOGpermission:android.permission.USE_SIPpermission:android.permission.PROCESS_OUTGOING_CALLSpermission:com.android.voicemail.permission.ADD_VOICEMAILpermission:android.permission.READ_CALENDARpermission:android.permission.WRITE_CALENDARpermission:android.permission.CAMERApermission:android.permission.BODY_SENSORSpermission:android.permission.ACCESS_FINE_LOCATIONpermission:android.permission.ACCESS_COARSE_LOCATIONpermission:android.permission.READ_EXTERNAL_STORAGEpermission:android.permission.WRITE_EXTERNAL_STORAGEpermission:android.permission.RECORD_AUDIOpermission:android.permission.READ_SMSpermission:android.permission.RECEIVE_WAP_PUSH permission:android.permission.RECEIVE_MMSpermission:android.permission.RECEIVE_SMSpermission:android.permission.SEND_SMSpermission:android.permission.READ_CELL_BROADCASTS 至于如何适配6.0之后的手机，主要有2种方式1.app的build.gradle中 targetSdkVersion =23则需要写相应的适配代码12345678910public static boolean hasPermission(@NonNull Context context, @NonNull String... permissions) &#123; if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) return true; for (String permission : permissions) &#123; boolean hasPermission = (ContextCompat.checkSelfPermission(context, permission) == PackageManager .PERMISSION_GRANTED); if (!hasPermission) return false; &#125; return true; &#125; 我们先判断android版本，有没有权限，然后若没有权限就申请1234567public static void requestPermission(@NonNull Activity activity, int requestCode, @NonNull String... permissions) &#123; String [] ps=new String[permissions.length]; for (int i=0;i&lt;permissions.length;i++)&#123; ps[i]=permissions[i]; &#125; ActivityCompat.requestPermissions(activity, ps, requestCode); &#125; 然后就是权限授予的回调1234@Overridepublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; //这里就可以处理了&#125; 如果用户拒绝了授予，则可以使用如下方法给用户解释为什么需要该权限，返回true我们就弹出解释对话框,12345678910public static boolean shouldShowRationalePermissions(Object o, String... permissions) &#123; for (String permission : permissions) &#123; if (o instanceof Activity) &#123; return ActivityCompat.shouldShowRequestPermissionRationale((Activity) o, permission); &#125; else if (o instanceof android.support.v4.app.Fragment) &#123; return ((android.support.v4.app.Fragment) o).shouldShowRequestPermissionRationale(permission); &#125; &#125; return false;&#125; 如果用户不但拒绝，还点击了不再提醒，就比较麻烦了，因为不会再有授权框了，我们只能检测如果权限拒绝了，弹出提示框，要用户到权限管理中心去开启权限。12345678public static boolean hasAlwaysDeniedPermissio(Object o, @NonNull List&lt;String&gt; deniedPermissions) &#123; for (String deniedPermission : deniedPermissions) &#123; if(!shouldShowRationalePermissions(o,deniedPermission)) return true; &#125; return false;&#125; 以上就是处理6.0以上的权限问题，但不一定适配国产等机型，毕竟国内各大Rom修改源码比较严重，有自家的权限管理，需要特殊处理。目前github上开源的权限管理也有不少 lovedise的PermissionGen PermissionGen的升级版 yanzhenjie的AndPermission hotchemi的PermissionsDispatcher,插件地址permissions-dispatcher-plugin k0shk0sh的PermissionHelper ParkSangGwon的TedPermission Google官方googlesamples的easypermissions anthonycrd的Grant 基于Rx的RxPermissions Karumi的Dexter 张鸿洋的MPermissions 各有优劣，不过对于国产手机，自带权限管理可能需要自行适配了哦。","tags":[{"name":"随笔","slug":"随笔","permalink":"//dongqing123.cn/tags/随笔/"},{"name":"Android","slug":"Android","permalink":"//dongqing123.cn/tags/Android/"}]},{"title":"realm简单使用","date":"2017-01-13T10:22:57.000Z","path":"2017/01/13/realm简单使用/","text":"数据库——android四大存储之一，说实话已经很久没有使用了，平时是要使用网络与文件存储，除非是需要离线模式，或者有特殊的要求。realm——一款轻量级的移动端数据库，相比SQLite和其他orm框架有着其许多的优点，以前只是听过，今天来一睹庐山真面目。相比SQLite，Realm更快并且具有很多现代数据库的特性，比如支持JSON，流式api（Rx），数据变更通知，以及加密支持，这些都为安卓开发者带来了方便。 如何使用依赖首先是在project的build.gradle中添加1234dependencies &#123; ... classpath \"io.realm:realm-gradle-plugin:2.2.2\"&#125; 然后是app的build.gradle中在apply plugin: &#39;com.android.application&#39;下面添加1apply plugin: 'realm-android' 现在我们sync project 就可以了。 创建realm我们需要在自定义一个类继承Application12345678910public class AppContext extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); RealmConfiguration config = new RealmConfiguration.Builder()// .name(\"myRealm.realm\") .build(); Realm.setDefaultConfiguration(config); &#125;&#125; 注释部分为realm的名称，我们使用默认的default.realm。 不要忘记在manifest中使用我们自定义的Application。 创建RealmObject只要继承了RealmObject类，任意JavaBean都能存储在Realm中。1234567891011121314151617181920public class RealmBean extends RealmObject &#123; private String openId; private boolean isRead; public String getOpenId() &#123; return openId; &#125; public void setOpenId(String openId) &#123; this.openId = openId; &#125; public boolean isRead() &#123; return isRead; &#125; public void setRead(boolean read) &#123; isRead = read; &#125;&#125; 工具类1. 插入 12345678public static void insertRealm(String openId) &#123; Realm realm = Realm.getDefaultInstance(); realm.beginTransaction(); RealmBean bean = realm.createObject(RealmBean.class); bean.setOpenId(openId); bean.setRead(false); realm.commitTransaction();&#125; 你可能注意到了bean并不是用Country类的构造器创建的。对于一个Realm来说，管理一个RealmObject的实例，这个实例必须用createObject方法创建。如果你必须使用构造器，别忘了在提交事务前使用相关Realm对象的copyToRealm方法。123456789public static void insertRealm(String openId) &#123; Realm realm = Realm.getDefaultInstance(); realm.beginTransaction(); RealmBean bean = new RealmBean(); bean.setOpenId(openId); bean.setRead(false); realm.copyToRealm(bean); realm.commitTransaction();&#125; 2. 删除12345678public static RealmBean deleteRealm(String openId) &#123; Realm mRealm = Realm.getDefaultInstance(); RealmBean bean = mRealm.where(RealmBean.class).equalTo(\"openId\", openId).findFirst(); mRealm.beginTransaction(); bean.deleteFromRealm(); mRealm.commitTransaction(); return bean;&#125; 3. 修改1234567public static void updateRealm(String openId) &#123; Realm mRealm = Realm.getDefaultInstance(); RealmBean bean = mRealm.where(RealmBean.class).equalTo(\"openId\", openId).findFirst(); mRealm.beginTransaction(); bean.setRead(true); mRealm.commitTransaction();&#125; 4. 查询12345678910public static RealmBean queryRealm(String openId) &#123; Realm mRealm = Realm.getDefaultInstance(); RealmBean bean = mRealm.where(RealmBean.class).equalTo(\"openId\", openId).findFirst(); return bean;&#125;public static List&lt;RealmBean&gt; queryRealmList(boolean isRead) &#123; Realm mRealm = Realm.getDefaultInstance(); RealmResults&lt;RealmBean&gt; bean = mRealm.where(RealmBean.class).equalTo(\"isRead\", isRead).findAll(); return bean;&#125; 条件查询，Realm 支持以下查询条件 between()、greaterThan()、lessThan()、greaterThanOrEqualTo() 和 lessThanOrEqualTo()。 equalTo() 和 notEqualTo()。 contains()、beginsWith() 和 endsWith()。 isNull() 和 isNotNull()。 isEmpty() 和 isNotEmpty()。 以上就是realm的基本用法，虽然realm简单快捷方便，但还是有许多的短板。 缺点 不是基于sqlite的，他有自己的存储引擎 ，存储不是基于表的，所以联表查询不支持。 所有的数据模型必须直接继承自RealmObject。这阻碍我们利用数据模型中的任意类型的继承。 Realm 没有自动增长属性。 Realm对象的 Setters &amp; Getters 不能被重载 尽管 Realm 文件可以被多个线程同时访问，但是您不能跨线程处理 Realms、Realm 对象、查询和查询结果。 总结realm的优点自然不用多说，一个字：快。在保证了ACID的要求下，很多设计都是以速度为主。当然，Realm 最核心的理念就是对象驱动，这是 Realm 的核心原则。Realm 本质上是一个嵌入式数据库，但是它也是看待数据的另一种方式。它用另一种角度来重新看待移动应用中的模型和业务逻辑。Realm还是跨平台的，多个平台都使用相同的数据库，是多么好的一件事情呀。相信使用Realm作为App数据库的开发者会越来越多。","tags":[{"name":"Android","slug":"Android","permalink":"//dongqing123.cn/tags/Android/"},{"name":"数据库","slug":"数据库","permalink":"//dongqing123.cn/tags/数据库/"},{"name":"realm","slug":"realm","permalink":"//dongqing123.cn/tags/realm/"}]},{"title":"Retrofit使用","date":"2017-01-10T08:25:52.000Z","path":"2017/01/10/Retrofit使用/","text":"&#8195;&#8195;上篇我们介绍了OkHttp的使用，OkHttp虽说是网络请求，但和velley、nohttp等不大相同，它属于底层的东西，是没有经过封装的。今天我们讨论的retrofit就是对okhttp进行了封装，是一个非常棒的网络请求框架。&#8195;&#8195;retrofit是主要是通过注解的形式来写请求接口，并且支持Rx，配合使用有奇效。 如何使用首先当然是依赖12345compile 'com.squareup.retrofit2:retrofit:2.1.0'compile 'com.squareup.retrofit2:converter-gson:2.1.0'//compile 'com.squareup.retrofit2:adapter-rxjava:2.1.0'//compile 'io.reactivex:rxandroid:1.2.1'//compile 'io.reactivex:rxjava:1.2.3' *注释部分是配合rx使用。然后java部分我们先写个接口类用于网络请求123456789101112131415161718192021222324public interface ApiService &#123; /** * 每日一Gank **/ @GET(\"day/&#123;year&#125;/&#123;month&#125;/&#123;day&#125;\") Call/*Observable*/&lt;GankData&gt; getDayData(@Path(\"year\") int year,@Path(\"month\") int month, @Path(\"day\") int day); /** * 获取IP信息 **/ @FormUrlEncoded @POST(\"service/getIpInfo.php\") Call/*Observable*/&lt;IpInfo&gt; getIpInfo(@Field(\"ip\") String ip); /** * 上传头像 **/ @Multipart @POST(\"uptUserHeadImg\") Call/*Observable*/&lt;UserBean&gt; uploadHead(@Part MultipartBody.Part photo, @Part(\"uid\") RequestBody userId); /** * 下载图片 */ @GET Call/*Observable*/&lt;ResponseBody&gt; downloadPicFromNet(@Url String fileUrl);&#125; *注释部分是配合Rx使用这里我们介绍一下retrofit的注解 get请求 @GET 申明get请求方式，括号里面是请求路径。 @Query 请求参数对应的键值，括号内为key，参数为value。 @QueryMap 如果Query参数比较多，那么可以通过@QueryMap方式将所有的参数集成在一个Map。 @Path 会把参数填充到路径上，如上面的@Path(&quot;year&quot;) @Path(&quot;month&quot;) @Path(&quot;day&quot;) 会填充@GET(&quot;day/{year}/{month}/{day}&quot;) 中的year、month、day。@Path可用于任何请求方式。 @Url 不使用baseUrl。 post请求 @POST 申明post请求方式，括号里面是请求路径。 @FormUrlEncoded 自动将请求参数的类型调整为application/x-www-form-urlencoded，FormUrlEncoded不能用于Get请求。 @Field 请求参数对应的键值。 @FieldMap 如果Field参数比较多，那么可以通过@FieldMap 方式将所有的参数集成在一个Map。 @Body 请求参数有多个，那么统一封装到类中应该会更好，这样维护起来会非常方便。 上传文件 @Multipart 申明为上传文件方式。 @Part 参数列表 MultipartBody.Part 为文件类型，RequestBody 为一般参数。 @PartMap 如果Part参数比较多，那么可以通过@PartMap 方式将所有的参数集成在一个Map。@PartMap Map&lt;String, RequestBody&gt; params 可以是多个文件，也可是文件与参数混合。 接口类写好后，我们要写个单例模式的网络请求类12345678910111213141516171819202122232425262728293031323334353637public class Api &#123; public static final String BASE_URL = \"http://gank.io/api/\"; public final static MediaType TYPE_IMAGE = MediaType.parse(\"image/*\"); public static final int DEFAULT_TIMEOUT = 30; public Retrofit retrofit; public ApiService service; //构造方法私有 private Api() &#123; OkHttpClient okHttpClient = new OkHttpClient.Builder() .readTimeout(DEFAULT_TIMEOUT, TimeUnit.SECONDS) .connectTimeout(DEFAULT_TIMEOUT, TimeUnit.SECONDS) .build(); Gson gson = new GsonBuilder().setDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").serializeNulls().create(); retrofit = new Retrofit.Builder() .client(okHttpClient) .addConverterFactory(GsonConverterFactory.create(gson)) //.addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .baseUrl(BASE_URL) .build(); service = retrofit.create(ApiService.class); &#125; //在访问HttpMethods时创建单例 private static class SingletonHolder &#123; private static final Api INSTANCE = new Api(); &#125; //获取单例 public static Api getInstance() &#123; return SingletonHolder.INSTANCE; &#125; 到这里基本上完成一大半，下面我们开始在Activity、fragment等中调用。12345678910111213141516171819202122232425262728293031323334353637383940414243Calendar calender = Calendar.getInstance();calender.setTime(date); //Rx使用方式Api.getInstance().service.getDayData(calender.get(Calendar.YEAR), calender.get(Calendar.MONTH) + 1, calender.get(Calendar.DAY_OF_MONTH)) .subscribeOn(Schedulers.io()) .map(new Func1&lt;GankData, GankData.ResultsBean&gt;() &#123; @Override public GankData.ResultsBean call(GankData gankData) &#123; return gankData.getResults(); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;GankData.ResultsBean&gt;() &#123; @Override public void onCompleted() &#123; Log.v(\"success:\", \"onCompleted\"); &#125; @Override public void onError(Throwable e) &#123; Log.v(\"failure:\", \"onError\"); &#125; @Override public void onNext(GankData.ResultsBean resultsBean) &#123; &#125; &#125;); //call使用方式Api.getInstance().service.getDayData(calender.get(Calendar.YEAR), calender.get(Calendar.MONTH) + 1, calender.get(Calendar.DAY_OF_MONTH)) .enqueue(new Callback&lt;GankData&gt;() &#123; @Override public void onResponse(Call&lt;GankData&gt; call,Response&lt;GankData&gt; response) &#123; &#125; @Override public void onFailure(Call&lt;GankData&gt; call, Throwable t) &#123; &#125;&#125;); 其他的接口也是类似的操作。 总结&#8195;&#8195; retrofit使用起来还是蛮方便的，其他还有header、日志、拦截器等的内容没有介绍，考虑到一般情况下是不需要对这些进行操作的 。使用retrofit后台必须遵循restful原则，具体概念可上网了解。例子中使用到了Rx等相关的知识，了解java后端的应该对链式操作有所了解，需要学习的小伙伴可参考抛物线的给 Android 开发者的 RxJava 详解 ，这篇文章对Rx进行了详细的解读。目前Rx 2.0的版本也已发布，相对1.0有些许改动。","tags":[{"name":"Android","slug":"Android","permalink":"//dongqing123.cn/tags/Android/"},{"name":"网络请求","slug":"网络请求","permalink":"//dongqing123.cn/tags/网络请求/"},{"name":"retrofit","slug":"retrofit","permalink":"//dongqing123.cn/tags/retrofit/"}]},{"title":"React Native 配置","date":"2017-01-04T03:22:26.000Z","path":"2017/01/04/React-Native-配置/","text":"&#8195;&#8195;近年来随着移动互联网的发展，移动可以说在飞速的进步，加上各种培训机构，市场上涌入了大堆大堆的新人加入到手机App的行业，从而形成了饱和的状态。从2016年初开始，移动开发出现了各种低潮，从找工作这一方面来看，明显难度高了好多，公司都不愿意招手机app的人员，反而愿意招收后端开发。明明年底是跳槽的一次进修，现在都开始观望了，不敢轻易，当然实力大牛这些对他们来说影响不大。不过最近出现了许多替代原生开发的工具，从早期的phoneGap,到比较火的H5，以及2015年出现RN，听说微信的“小程序”也想分一杯羹。各种原生已死的评论到处都是，作为手机开发人员当然知道这些目前还不太可能，但是也不能坐吃山空，墨守成规。对于这些新技术也是要了解一下的。&#8195;&#8195;React Native 目前也有一年多的历史了，应用商店也有许多基于RN的App，应该算是比较成熟了，但官方依然还是0.x.x的版本，正式版不知何时发布。 RN环境配置在RN中文网上有详细的搭建开发环境，一般按着步骤走是可行的，若安装较慢可以使用科学上网或者换淘宝的镜像。 ##搭建RN项目环境搭建完成后，是时候开始学习RN了，我们先从新建项目开始，官方是通过123react-native init AwesomeProjectcd AwesomeProjectreact-native run-android 命令来实现项目的新建与运行（部分手机会crash需要到权限管理中心开启悬浮窗权限），也可参考江清清的博客React Native专题中的两篇React Native For Android环境配置以及第一个实例、React Native移植原生Android项目-已更新版本-New。如果你已新建项目并且Android没有修改代码可以通过以下操作12adb reverse tcp:8081 tcp:8081react-native start 上面命令来启动服务，手机打开RN项目通过重新加载JS就可以了（摇一摇或者按menu菜单键选择Reload）。 编辑JSRN相比原生最方便的就是修改代码（不涉及原生代码）不需要重新安装，只需要重新加载JS就可以了，非常的方便。而且大部分JS代码Android与iOS是可以共用的，可以说是实现了一套代码两个版本。编辑JS的IDE可供选择的有很多，atom、webstorm、sublime text3等等，可根据个人习惯选择。 最后本篇主要说的是RN的环境配置与搭建RN项目，平时在业余时间可以用来练练手，学习学习。但是用于商业项目还是需要相当谨慎的，也许会遇到很多很多的填不完的坑。","tags":[{"name":"Android","slug":"Android","permalink":"//dongqing123.cn/tags/Android/"},{"name":"RN","slug":"RN","permalink":"//dongqing123.cn/tags/RN/"}]},{"title":"OkHttp的使用","date":"2017-01-04T03:20:51.000Z","path":"2017/01/04/OkHttp的使用/","text":"网络请求框架我一直都使用httpclient，后来改成了xutils，但是去年开始自从Android6.0去掉了httpclient的支持，想要使用还要在build.gradle添加useLibrary &#39;org.apache.http.legacy&#39;，加上google的推广，Okhttp变得非常火了起来，于是自己也修改自己的网络框架。我使用时OkHttp已经出现3.0的版本了，与2.0的版本还是有一些差别的 get基本上没有什么区别 2.0123456OkHttpClient client = new OkHttpClient();client.setConnectTimeout(15,TimeUnit.SECONDS);client.setWriteTimeout(20,TimeUnit.SECONDS); client.setReadTimeout(20,TimeUnit.SECONDS);Request request = new Request.Builder().url(url).build();Response response = client.newCall(request).execute(); 3.0123456OkHttpClient client = new OkHttpClient();client.newBuilder().connectTitmeout(15,TimeUnit.SECONDS)client.newBuilder().readTimeout(15,TimeUnit.SECONDS)client.newBuilder().wirteTimeout(15,TimeUnit.SECONDS)Request request = new Request.Builder().url(url).build();Response response = client.newCall(request).execute(); post取消了FormEncodingBuilder使用FormBody 2.01234OkHttpClient client = new OkHttpClient();RequestBody requestBody = new FormEncodingBuilder() .add(\"\",\"\").add(\"\",\"\").build();Request request = new Request.Builder().url(url).post(requestBody).build();Response response = client.newCall(request).execute(); 3.01234OkHttpClient client = new OkHttpClient();RequestBody requestBody = new FormBody.Builder().add(\"\",\"\").add(\"\",\"\").build();Request request = new Request.Builder().url(url).post(requestBody).build();Response response = client.newCall(request).execute(); 上传文件MultipartBuilder改为MultipartBody 2.0123456789OkHttpClient client = new OkHttpClient();MultipartBuilder multipartEntity = new MultipartBuilder().type(MultipartBuilder.FORM); File file = new File(tmepName);RequestBody fileBody = RequestBody.create(MediaType.parse(\"image/*\"), file);multipartEntity.addFormDataPart(key,file.getName(), fileBody);multipartEntity.addFormDataPart(key, value);RequestBody requestBody = multipartEntity.build();Request request = new Request.Builder().url(url).post(requestBody).build();Response response = client.newCall(request).execute(); 3.0123456789OkHttpClient client = new OkHttpClient();MultipartBody.Builder multipartEntity = new MultipartBody.Builder();File file = new File(tmepName);RequestBody fileBody = RequestBody.create(MediaType.parse(\"image/*\"), file);multipartEntity.addFormDataPart(key,file.getName(), fileBody);multipartEntity.addFormDataPart(key, value);RequestBody requestBody = multipartEntity.build();Request request = new Request.Builder().url(url).post(requestBody).build();Response response = client.newCall(request).execute(); cookie使用cookieJar替代cookieHandler持久化文件 2.01client.setCookieHandler(new CokieManager(new PersistentCookieStore(context), CookiePolicy.ACCEPT_ALL)); 3.01client.newBuilder().cookieJar(new CookiesManager()); 以上就是OkHttp的简单使用以及2.0与3.0的差异，下一篇我们讲解retrofit。","tags":[{"name":"Android","slug":"Android","permalink":"//dongqing123.cn/tags/Android/"},{"name":"网络请求","slug":"网络请求","permalink":"//dongqing123.cn/tags/网络请求/"},{"name":"okHttp","slug":"okHttp","permalink":"//dongqing123.cn/tags/okHttp/"}]},{"title":"2016年总结","date":"2016-12-31T03:21:33.000Z","path":"2016/12/31/2016年总结/","text":"&#8195;&#8195;时间总是过的飞快，转眼之间2016年已经没剩几天了，想想自己都是26岁的人了，离自己的梦想也渐行渐远。&#8195;&#8195;回顾这一整年，发现自己干的琐事确实蛮多的，但坚持的事总是没有，想想自己都快毕业3年了，还是碌碌无为呀。反而看了许多人写的年终总结，发现自己与他们的差距真的是非常的大，人家一年做了好多好多的实事，而我一年都不知道干了什么。&#8195;&#8195;说实话我是不喜欢写总结来着，这算是我第一次。想想自己都出来3年了，考研的现在也该毕业了，自己的年龄也是越来越大，精力也不想以前那么充沛了，实在不想再浑浑噩噩的过日子。&#8195;&#8195;废话说了这么多，看看我16年都干了些什么。&#8195;&#8195;想了想实在不知道干么了。。。&#8195;&#8195;3月份当时点窝业务还在，还在维护点窝商城与电视TV，还有就是我的手下离职了，我成了孤家寡人，之后就开始做电子券与供销通的业务。&#8195;&#8195;说起来就觉得公司比较坑，app做了一版又一版就是没有投入使用，给我的感觉就是我做的app一个都没上线。之后我就开始投入到万千同性交友网站github的怀抱，写demo。&#8195;&#8195;好了基本上就这些，然后就是学习。&#8195;&#8195;学习drag2、mvp 、rx、okhttp、retrofit等等开源框架，订阅与关注了许多大牛，了解RN、热修复等等相关的知识，写写演示Demo。&#8195;&#8195;到12月份的时候，我终于打算写个人app上线应用商店。我开始基于gank.io写我的个人app，注册了三大平台的账号，前前后后花了大概3周的时间终于上线了，但也仅仅是上线了。&#8195;&#8195;写完我是真发现没做什么实事呢。&#8195;&#8195;2017年真是希望自己有所改变，不管是技术还是人际。","tags":[{"name":"随笔","slug":"随笔","permalink":"//dongqing123.cn/tags/随笔/"},{"name":"总结","slug":"总结","permalink":"//dongqing123.cn/tags/总结/"}]},{"title":"Hello World","date":"2016-12-28T06:16:40.000Z","path":"2016/12/28/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]