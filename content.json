[{"title":"26岁，你该明白","date":"2017-02-04T01:43:42.000Z","path":"2017/02/04/26岁，你该明白/","text":"想学什么就学什么，开始做一件事，永远都不会太晚。 警惕到处给人励志的人，实际上他们是在为自己励志而已，往往自己做不到才需要励志。 看多些书，写多些字，少说些话。 第一眼看上去就讨厌的人，你很难改变对他们的印象。尽可能去远的地方看看，世界还有比你想象中更好的地方。 公司永远都不是自己的家，如果有个老板说公司就是家，说用家庭式管理来这个公司，尽快离开这个公司。 不要借钱给朋友，否则你会失去这个朋友。如果一定要借，救急不救穷。 工作同事要求助，首先要判断自己是不是一定要做，其次要问他懂不懂，如果他不懂，一定要教，教三次后他还是不会，就永远教不会了，你也不必再教了，他一般也不会在找你了。 胖子的自制力都比较差。 重复旧的做法，只会得到旧的结果。 不要回头，向前走，工作如此，爱情如此。 安慰失败或者做错事的人，可以这么说：动机和情绪总不会有错，只不过行为没有效果而已。 奥卡姆剃刀定理：如无需要，切勿增加实体。 断舍离：任何物品都会有用处的，判断自己需不需要，如果不需要，果断地扔掉。 经常去去展览馆，不能保证你能马上提高艺术品位，不过能让你有个好心情。 找个价值观一致的伴侣，会省掉很多争吵和磨合的时间，然后去做各自喜欢的事情。 和伴侣吵架，赢了没有用，要看效果。 不要相信自己和别人有什么不同，励志的话诸如you are Special，you are Unique都是真的，但是接受自己是个普通人事实更重要。 大多数成功的人会说自己是幸运而已，努力，应该是一种常有的状态。 试错法是人生的好方法，用得越多，效果越好，年龄一大，成本越大。 与其烦恼，不如思考。人的一切痛苦，本质是都是对自己无能的愤怒。 任何事情，你知道了不去做等于不知道。 孤独是人生的重要伴侣，没有人能够陪伴你到最后，要和自己好好相处。 在你面前说你坏话的人都是关心希望你好你的人，在你背后说的坏话的，也不要介意，不是每个人都喜欢你的，接受这个事实，再做好自己就好。 打造人脉不如打造自己。如果你是一个优秀、有价值的人，那么就会有很多另外优秀、有价值的人为你提供帮助。 解决任何问题的第一步，是要承认问题的存在。First step in solving any problem is recognizing there is one. 不要去追求自由，自由是外界给的，要追独立。","tags":[{"name":"随笔","slug":"随笔","permalink":"//dongqing123.cn/tags/随笔/"}]},{"title":"android design库的使用（一）","date":"2017-01-24T08:05:26.000Z","path":"2017/01/24/android-design库的使用（一）/","text":"android5.0带来的Material Design是非常惊艳的，为了能让这个的设计支持低版本的版本，google提供了design库。今天我们的主角是android的抽屉菜单DrawerLayout及配套使用的一些控件。 最简单的例子就是用Android Studio自带的功能,我们新建一个Activity在模本中选择Navigation drawer Activity 然后finish，这样抽屉菜单就生成了，然后你会看到一个activity与4个layout。我们先看一下效果 效果还不错吧，现在我们来看看布局 activity_main.xml12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/drawer_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" tools:openDrawer=\"start\"&gt; &lt;include layout=\"@layout/app_bar_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; &lt;android.support.design.widget.NavigationView android:id=\"@+id/nav_view\" android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:layout_gravity=\"start\" android:fitsSystemWindows=\"true\" app:headerLayout=\"@layout/nav_header_main\" app:menu=\"@menu/activity_main_drawer\" /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; DrawerLayout是抽屉菜单，include是主页的内容，NavigationView是菜单的内容我们来看看主页的内容app_bar_main.xml12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" tools:context=\"com.jsqix.dongqing.demo.MainActivity\"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:theme=\"@style/AppTheme.AppBarOverlay\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"?attr/colorPrimary\" app:popupTheme=\"@style/AppTheme.PopupOverlay\" /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;include layout=\"@layout/content_main\" /&gt; &lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/fab\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom|end\" android:layout_margin=\"@dimen/fab_margin\" app:srcCompat=\"@android:drawable/ic_dialog_email\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 然后是cotent_main.xml12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/content_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" tools:context=\"com.jsqix.dongqing.demo.MainActivity\" tools:showIn=\"@layout/app_bar_main\"&gt;&lt;/RelativeLayout&gt; 最后是nav_header_main.xml1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"@dimen/nav_header_height\" android:background=\"@drawable/side_nav_bar\" android:gravity=\"bottom\" android:orientation=\"vertical\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark\"&gt; &lt;ImageView android:id=\"@+id/imageView\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:paddingTop=\"@dimen/nav_header_vertical_spacing\" app:srcCompat=\"@android:drawable/sym_def_app_icon\" /&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:paddingTop=\"@dimen/nav_header_vertical_spacing\" android:text=\"Android Studio\" android:textAppearance=\"@style/TextAppearance.AppCompat.Body1\" /&gt; &lt;TextView android:id=\"@+id/textView\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"android.studio@android.com\" /&gt;&lt;/LinearLayout&gt; 及menu123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;group android:checkableBehavior=\"single\"&gt; &lt;item android:id=\"@+id/nav_camera\" android:icon=\"@drawable/ic_menu_camera\" android:title=\"Import\" /&gt; &lt;item android:id=\"@+id/nav_gallery\" android:icon=\"@drawable/ic_menu_gallery\" android:title=\"Gallery\" /&gt; &lt;item android:id=\"@+id/nav_slideshow\" android:icon=\"@drawable/ic_menu_slideshow\" android:title=\"Slideshow\" /&gt; &lt;item android:id=\"@+id/nav_manage\" android:icon=\"@drawable/ic_menu_manage\" android:title=\"Tools\" /&gt; &lt;/group&gt; &lt;item android:title=\"Communicate\"&gt; &lt;menu&gt; &lt;item android:id=\"@+id/nav_share\" android:icon=\"@drawable/ic_menu_share\" android:title=\"Share\" /&gt; &lt;item android:id=\"@+id/nav_send\" android:icon=\"@drawable/ic_menu_send\" android:title=\"Send\" /&gt; &lt;/menu&gt; &lt;/item&gt;&lt;/menu&gt; 现在我们来分析一下布局，首先是drawer，里面包含主页与菜单，菜单是通过head与menu来组装，然后主页里面就是CoordinatorLayout包裹的内容，里面AppBarLayout包裹着Toolbar，还有一个content，最后是FloatingActionButton，content就是我们需要写的布局代码。 今天我们就分析NavigationView的使用通过上面布局我们知道NavigationView主要有两个部分组成，head与menu。head是NavigationView的头，一般用来显示头像等，menu就是一些菜单。android:layout_gravity=&quot;start&quot; 代表是左滑菜单，相应的end便是右滑菜单（建议用start代替left，end代替right，这样可以国际化）。我们再来分析菜单布局文件必须使用menu标签作为根节点。除了menu标签外，还有另外两个标签用于设置菜单项和分组，这两个标签是item和group。menu标签没有任何属性，但可以嵌套在item标签中，表示子菜单的形式。不过item标签中不能再嵌入item标签。 item标签的属性 id，这个大家都知道 menuCategory，同种菜单项的种类 orderInCategor，同种类菜单的排列顺序，值越大越靠前 title，标题 titleCondensed，短标题，当title太长时会显示该属性值 icon，图标 alphabeticShortcut，字母快捷键 numericShortcut，数字快捷键 checkable，是否带复选框 checked，复选框的默认选中 visible，可不可见 enable，可不可操作 group标签的属性 menuCategory，菜单组的种类 orderInCategory，菜单组的排序 checkableBehavior，该组所有菜单项上显示的选择组件，all为CheckBox，single为RadioButton，none为正常的菜单项 visible，菜单组是否可见 enable，菜单组是否可操作 这样我们便可以生产菜单menu文件了。 菜单的事件操作 head中必须通过12NavigationView navigationView = (NavigationView) findViewById(R.id.nav_view);View headerView=navigationView.getHeaderView(0); 通过headerView的findViewById找到相应的组件来进行操作。 menu中setNavigationItemSelectedListener来监听123456NavigationView navigationView = (NavigationView) findViewById(R.id.nav_view);navigationView.setNavigationItemSelectedListener(this);@Overridepublic boolean onNavigationItemSelected(MenuItem item) &#123;&#125; 到这里基本上是完成了滑动菜单，但是这还是不够的。NavigationView 默认是随主题的，菜单默认是灰色的，group菜单选中之后默认是colorPrimary的颜色，如果你需要修改,可以通过如下属性 app:itemIconTint，设置图片的颜色 app:itemTextColor，设置字体颜色 app:itemBackground，设置背景颜色 app:itemTextAppearance，设置字体的TextAppearance 如果你的菜单还需要其他什么功能，比如QQ在右下角显示设置，主题等操作，可以在NavigationView中写你想要的布局如123456789101112131415161718192021222324252627282930313233343536373839404142...&lt;android.support.design.widget.NavigationView android:id=\"@+id/nav_view\" android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:layout_gravity=\"start\" android:fitsSystemWindows=\"true\" app:headerLayout=\"@layout/nav_header_main\" app:menu=\"@menu/activity_main_drawer\"&gt; &lt;RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom\" android:paddingBottom=\"15dp\" android:paddingLeft=\"10dp\" android:paddingRight=\"10dp\"&gt; &lt;TextView android:id=\"@+id/btn_set\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:drawableLeft=\"@mipmap/ic_menu_set\" android:drawablePadding=\"5dp\" android:gravity=\"center\" android:text=\"设置\" android:textColor=\"@color/black\" /&gt; &lt;TextView android:id=\"@+id/btn_theme\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentRight=\"true\" android:layout_marginRight=\"20dp\" android:drawableLeft=\"@mipmap/ic_menu_theme\" android:drawablePadding=\"5dp\" android:gravity=\"center\" android:text=\"主题\" android:textColor=\"@color/black\" /&gt; &lt;/RelativeLayout&gt;&lt;/android.support.design.widget.NavigationView&gt;··· 如果这些还不能满足你，可以试试MaterialDrawer功能强大，可定制高，还支持主题切换。","tags":[{"name":"android","slug":"android","permalink":"//dongqing123.cn/tags/android/"},{"name":"design","slug":"design","permalink":"//dongqing123.cn/tags/design/"},{"name":"drawer","slug":"drawer","permalink":"//dongqing123.cn/tags/drawer/"},{"name":"navigationView","slug":"navigationView","permalink":"//dongqing123.cn/tags/navigationView/"}]},{"title":"RecyclerView与CardView的使用","date":"2017-01-23T07:09:18.000Z","path":"2017/01/23/RecyclerView与CardView的使用/","text":"2014年google发布了android5.0的版本，系统使用一种新的Material Design设计风格，也给我们带来了很多新的特性，RecyclerView与CardView就是起新的两个组件。以前我们写列表布局时都是用ListView、GridView等控件，比较繁琐的就是写Adapter了，而且还要对其优化加入viewholder类。现在RecyclerView就可以替代ListView、GridView，而且自带Holder，加上默认的三种布局方式，可以说给开发者带来很大的好处。 如何使用RecyclerView使用上与一般的AdapterView并没有什么区别，我们先在build.gradle中添加RecyclerView与CardView的依赖12345dependencies &#123; compile 'com.android.support:recylerview-v7:25.0.1' compile 'com.android.support:cardview-v7:25.0.1' ...&#125; layout中1234567...&lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recyclerView\" android:layout_width=\"match_parent\" android:overScrollMode=\"never\" android:layout_height=\"match_parent\" /&gt;... 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v7.widget.CardView xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:card=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"5dp\" android:layout_marginLeft=\"10dp\" android:layout_marginRight=\"10dp\" android:layout_marginTop=\"5dp\" card:cardBackgroundColor=\"@android:color/white\" card:cardCornerRadius=\"5dp\" card:cardElevation=\"2dp\" card:cardMaxElevation=\"5dp\"&gt; &lt;!--cardMaxElevation：最大卡片阴影的宽度--&gt; &lt;!--cardElevation:卡片阴影的宽度--&gt; &lt;!--cardBackgroundColor:卡片的背景颜色--&gt; &lt;!--cardCornerRadius ：卡片的圆角半径--&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;ImageView android:id=\"@+id/image\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:src=\"@mipmap/ic_launcher\" /&gt; &lt;TextView android:id=\"@+id/title\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"10dp\" android:text=\"1\" /&gt; &lt;/LinearLayout&gt;&lt;/android.support.v7.widget.CardView&gt; adapter1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class RecyclerAdapter extends RecyclerView.Adapter&lt;RecycleAdapter.MyViewHolder&gt; &#123; private Context context; private List&lt;String&gt; list; private OnItemClickListener onItemClickListener; public void setOnItemClickListener(OnItemClickListener onItemClickListener) &#123; this.onItemClickListener = onItemClickListener; &#125; public RecyclerAdapter(Context context, List&lt;String&gt; list) &#123; this.context = context; this.list = list; &#125; @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(context).inflate(R.layout.item_recycle, parent, false); return new MyViewHolder(view); &#125; @Override public void onBindViewHolder(MyViewHolder holder, final int position) &#123; final String bean = list.get(position); holder.imageView.setImageResource(R.mipmap.ic_launcher); holder.title.setText(bean); holder.itemView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; onItemClickListener.onItemClick(position); &#125; &#125;); &#125; @Override public int getItemCount() &#123; return list.size(); &#125; public class MyViewHolder extends RecyclerView.ViewHolder &#123; private ImageView imageView; private TextView title; public MyViewHolder(View view) &#123; super(view); imageView = (ImageView) view.findViewById(R.id.image); title = (TextView) view.findViewById(R.id.title); &#125; &#125; interface OnItemClickListener &#123; void onItemClick(int position); &#125;&#125; activity或fragment中1234LinearLayoutManager manager = new LinearLayoutManager(mContext, LinearLayoutManager.VERTICAL, false);recyclerView.setLayoutManager(manager);adapter = new RecyclerAdapter(mContext, R.layout.item_recycler, data);recyclerView.setAdapter(adapter); RecylerView使用必须指明LayoutManager，LayoutManager主要有三类 LinearLayoutManager 线性布局，有水平、垂直 GridLayoutManager 网格布局 StaggeredGridLayoutManager 瀑布流布局 通过ItemDecoration可以绘制item之间的间隔 ItemAnimator设置item的增删动画 click或longClick事件不支持，需要自己写 item 布局中使用了卡片布局CardView app:cardBackgroundColor这是设置背景颜色 app:cardCornerRadius这是设置圆角大小 app:cardElevation这是设置z轴的阴影 app:cardMaxElevation这是设置z轴的最大高度值 app:cardUseCompatPadding是否使用CompatPadding app:cardPreventCornerOverlap是否使用PreventCornerOverlap app:contentPadding 设置内容的padding app:contentPaddingLeft 设置内容的左padding app:contentPaddingTop 设置内容的上padding app:contentPaddingRight 设置内容的右padding app:contentPaddingBottom 设置内容的底padding 效果图 github上相关资源 RecyclerViewItemAnimators DividerItemDecoration RecyclerItemDecoration总结recyclerview作为listview、gridview的替代有着许多的优点，基本上可以完全代替，网上也有许多相关recyclerview的教程、自定义的控件、特效等，cardview卡片布局比较简单，但是实用性和效果是非常好的，用来当做背景再合适不过了。","tags":[{"name":"Android","slug":"Android","permalink":"//dongqing123.cn/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"//dongqing123.cn/tags/RecyclerView/"},{"name":"CardView","slug":"CardView","permalink":"//dongqing123.cn/tags/CardView/"}]},{"title":"android 6.0 权限管理","date":"2017-01-17T06:13:11.000Z","path":"2017/01/17/android-6-0-权限管理/","text":"&#8195;&#8195;如果说5.0是android上的里程碑，那么6.0就是对它的完善与升级。6.0从UI上与5.0没有任何区别，依旧坚持了好评的md风格，但不仅仅只是内核的升级而已。6.0首先是删除了apache的httpclient包，让一些网络请求框架需要对6.0进行适配，虽然有补救的方法，但官方删除了，也让okhttp更深入人心。然后就是今天我们重点讨论的权限管理。&#8195;&#8195;6.0以前的app安装时，会默认授予清单文件manifest中的权限，虽然安装时会告知用户有哪些权限，但一般很少有人会在意这一点。于是各种居心叵测的厂家或者开发者往往都是列一堆的权限，做着用户所不知道的事情。从6.0开始，情况就不一样了，一些危险的权限我们不但在写在manifest中，还需要用户授予同意才能使用。可以说扼杀了一部分厂家的利益。那么这些危险的权限有哪些呢?1234567891011121314151617181920212223242526272829303132permission:android.permission.WRITE_CONTACTSpermission:android.permission.GET_ACCOUNTSpermission:android.permission.READ_CONTACTSpermission:android.permission.READ_CALL_LOGpermission:android.permission.READ_PHONE_STATEpermission:android.permission.CALL_PHONEpermission:android.permission.WRITE_CALL_LOGpermission:android.permission.USE_SIPpermission:android.permission.PROCESS_OUTGOING_CALLSpermission:com.android.voicemail.permission.ADD_VOICEMAILpermission:android.permission.READ_CALENDARpermission:android.permission.WRITE_CALENDARpermission:android.permission.CAMERApermission:android.permission.BODY_SENSORSpermission:android.permission.ACCESS_FINE_LOCATIONpermission:android.permission.ACCESS_COARSE_LOCATIONpermission:android.permission.READ_EXTERNAL_STORAGEpermission:android.permission.WRITE_EXTERNAL_STORAGEpermission:android.permission.RECORD_AUDIOpermission:android.permission.READ_SMSpermission:android.permission.RECEIVE_WAP_PUSH permission:android.permission.RECEIVE_MMSpermission:android.permission.RECEIVE_SMSpermission:android.permission.SEND_SMSpermission:android.permission.READ_CELL_BROADCASTS 至于如何适配6.0之后的手机，主要有2种方式1.app的build.gradle中 targetSdkVersion =23则需要写相应的适配代码12345678910public static boolean hasPermission(@NonNull Context context, @NonNull String... permissions) &#123; if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) return true; for (String permission : permissions) &#123; boolean hasPermission = (ContextCompat.checkSelfPermission(context, permission) == PackageManager .PERMISSION_GRANTED); if (!hasPermission) return false; &#125; return true; &#125; 我们先判断android版本，有没有权限，然后若没有权限就申请1234567public static void requestPermission(@NonNull Activity activity, int requestCode, @NonNull String... permissions) &#123; String [] ps=new String[permissions.length]; for (int i=0;i&lt;permissions.length;i++)&#123; ps[i]=permissions[i]; &#125; ActivityCompat.requestPermissions(activity, ps, requestCode); &#125; 然后就是权限授予的回调1234@Overridepublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; //这里就可以处理了&#125; 如果用户拒绝了授予，则可以使用如下方法给用户解释为什么需要该权限，返回true我们就弹出解释对话框,12345678910public static boolean shouldShowRationalePermissions(Object o, String... permissions) &#123; for (String permission : permissions) &#123; if (o instanceof Activity) &#123; return ActivityCompat.shouldShowRequestPermissionRationale((Activity) o, permission); &#125; else if (o instanceof android.support.v4.app.Fragment) &#123; return ((android.support.v4.app.Fragment) o).shouldShowRequestPermissionRationale(permission); &#125; &#125; return false;&#125; 如果用户不但拒绝，还点击了不再提醒，就比较麻烦了，因为不会再有授权框了，我们只能检测如果权限拒绝了，弹出提示框，要用户到权限管理中心去开启权限。12345678public static boolean hasAlwaysDeniedPermissio(Object o, @NonNull List&lt;String&gt; deniedPermissions) &#123; for (String deniedPermission : deniedPermissions) &#123; if(!shouldShowRationalePermissions(o,deniedPermission)) return true; &#125; return false;&#125; 以上就是处理6.0以上的权限问题，但不一定适配国产等机型，毕竟国内各大Rom修改源码比较严重，有自家的权限管理，需要特殊处理。目前github上开源的权限管理也有不少 lovedise的PermissionGen PermissionGen的升级版 yanzhenjie的AndPermission hotchemi的PermissionsDispatcher,插件地址permissions-dispatcher-plugin k0shk0sh的PermissionHelper ParkSangGwon的TedPermission Google官方googlesamples的easypermissions anthonycrd的Grant 基于Rx的RxPermissions Karumi的Dexter 张鸿洋的MPermissions 各有优劣，不过对于国产手机，自带权限管理可能需要自行适配了哦。","tags":[{"name":"随笔","slug":"随笔","permalink":"//dongqing123.cn/tags/随笔/"},{"name":"Android","slug":"Android","permalink":"//dongqing123.cn/tags/Android/"}]},{"title":"realm简单使用","date":"2017-01-13T10:22:57.000Z","path":"2017/01/13/realm简单使用/","text":"数据库——android四大存储之一，说实话已经很久没有使用了，平时是要使用网络与文件存储，除非是需要离线模式，或者有特殊的要求。realm——一款轻量级的移动端数据库，相比SQLite和其他orm框架有着其许多的优点，以前只是听过，今天来一睹庐山真面目。相比SQLite，Realm更快并且具有很多现代数据库的特性，比如支持JSON，流式api（Rx），数据变更通知，以及加密支持，这些都为安卓开发者带来了方便。 如何使用依赖首先是在project的build.gradle中添加1234dependencies &#123; ... classpath \"io.realm:realm-gradle-plugin:2.2.2\"&#125; 然后是app的build.gradle中在apply plugin: &#39;com.android.application&#39;下面添加1apply plugin: 'realm-android' 现在我们sync project 就可以了。 创建realm我们需要在自定义一个类继承Application12345678910public class AppContext extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); RealmConfiguration config = new RealmConfiguration.Builder()// .name(\"myRealm.realm\") .build(); Realm.setDefaultConfiguration(config); &#125;&#125; 注释部分为realm的名称，我们使用默认的default.realm。 不要忘记在manifest中使用我们自定义的Application。 创建RealmObject只要继承了RealmObject类，任意JavaBean都能存储在Realm中。1234567891011121314151617181920public class RealmBean extends RealmObject &#123; private String openId; private boolean isRead; public String getOpenId() &#123; return openId; &#125; public void setOpenId(String openId) &#123; this.openId = openId; &#125; public boolean isRead() &#123; return isRead; &#125; public void setRead(boolean read) &#123; isRead = read; &#125;&#125; 工具类1. 插入 12345678public static void insertRealm(String openId) &#123; Realm realm = Realm.getDefaultInstance(); realm.beginTransaction(); RealmBean bean = realm.createObject(RealmBean.class); bean.setOpenId(openId); bean.setRead(false); realm.commitTransaction();&#125; 你可能注意到了bean并不是用Country类的构造器创建的。对于一个Realm来说，管理一个RealmObject的实例，这个实例必须用createObject方法创建。如果你必须使用构造器，别忘了在提交事务前使用相关Realm对象的copyToRealm方法。123456789public static void insertRealm(String openId) &#123; Realm realm = Realm.getDefaultInstance(); realm.beginTransaction(); RealmBean bean = new RealmBean(); bean.setOpenId(openId); bean.setRead(false); realm.copyToRealm(bean); realm.commitTransaction();&#125; 2. 删除12345678public static RealmBean deleteRealm(String openId) &#123; Realm mRealm = Realm.getDefaultInstance(); RealmBean bean = mRealm.where(RealmBean.class).equalTo(\"openId\", openId).findFirst(); mRealm.beginTransaction(); bean.deleteFromRealm(); mRealm.commitTransaction(); return bean;&#125; 3. 修改1234567public static void updateRealm(String openId) &#123; Realm mRealm = Realm.getDefaultInstance(); RealmBean bean = mRealm.where(RealmBean.class).equalTo(\"openId\", openId).findFirst(); mRealm.beginTransaction(); bean.setRead(true); mRealm.commitTransaction();&#125; 4. 查询12345678910public static RealmBean queryRealm(String openId) &#123; Realm mRealm = Realm.getDefaultInstance(); RealmBean bean = mRealm.where(RealmBean.class).equalTo(\"openId\", openId).findFirst(); return bean;&#125;public static List&lt;RealmBean&gt; queryRealmList(boolean isRead) &#123; Realm mRealm = Realm.getDefaultInstance(); RealmResults&lt;RealmBean&gt; bean = mRealm.where(RealmBean.class).equalTo(\"isRead\", isRead).findAll(); return bean;&#125; 条件查询，Realm 支持以下查询条件 between()、greaterThan()、lessThan()、greaterThanOrEqualTo() 和 lessThanOrEqualTo()。 equalTo() 和 notEqualTo()。 contains()、beginsWith() 和 endsWith()。 isNull() 和 isNotNull()。 isEmpty() 和 isNotEmpty()。 以上就是realm的基本用法，虽然realm简单快捷方便，但还是有许多的短板。 缺点 不是基于sqlite的，他有自己的存储引擎 ，存储不是基于表的，所以联表查询不支持。 所有的数据模型必须直接继承自RealmObject。这阻碍我们利用数据模型中的任意类型的继承。 Realm 没有自动增长属性。 Realm对象的 Setters &amp; Getters 不能被重载 尽管 Realm 文件可以被多个线程同时访问，但是您不能跨线程处理 Realms、Realm 对象、查询和查询结果。 总结realm的优点自然不用多说，一个字：快。在保证了ACID的要求下，很多设计都是以速度为主。当然，Realm 最核心的理念就是对象驱动，这是 Realm 的核心原则。Realm 本质上是一个嵌入式数据库，但是它也是看待数据的另一种方式。它用另一种角度来重新看待移动应用中的模型和业务逻辑。Realm还是跨平台的，多个平台都使用相同的数据库，是多么好的一件事情呀。相信使用Realm作为App数据库的开发者会越来越多。","tags":[{"name":"Android","slug":"Android","permalink":"//dongqing123.cn/tags/Android/"},{"name":"数据库","slug":"数据库","permalink":"//dongqing123.cn/tags/数据库/"},{"name":"realm","slug":"realm","permalink":"//dongqing123.cn/tags/realm/"}]},{"title":"Retrofit使用","date":"2017-01-10T08:25:52.000Z","path":"2017/01/10/Retrofit使用/","text":"&#8195;&#8195;上篇我们介绍了OkHttp的使用，OkHttp虽说是网络请求，但和velley、nohttp等不大相同，它属于底层的东西，是没有经过封装的。今天我们讨论的retrofit就是对okhttp进行了封装，是一个非常棒的网络请求框架。&#8195;&#8195;retrofit是主要是通过注解的形式来写请求接口，并且支持Rx，配合使用有奇效。 如何使用首先当然是依赖12345compile 'com.squareup.retrofit2:retrofit:2.1.0'compile 'com.squareup.retrofit2:converter-gson:2.1.0'//compile 'com.squareup.retrofit2:adapter-rxjava:2.1.0'//compile 'io.reactivex:rxandroid:1.2.1'//compile 'io.reactivex:rxjava:1.2.3' *注释部分是配合rx使用。然后java部分我们先写个接口类用于网络请求123456789101112131415161718192021222324public interface ApiService &#123; /** * 每日一Gank **/ @GET(\"day/&#123;year&#125;/&#123;month&#125;/&#123;day&#125;\") Call/*Observable*/&lt;GankData&gt; getDayData(@Path(\"year\") int year,@Path(\"month\") int month, @Path(\"day\") int day); /** * 获取IP信息 **/ @FormUrlEncoded @POST(\"service/getIpInfo.php\") Call/*Observable*/&lt;IpInfo&gt; getIpInfo(@Field(\"ip\") String ip); /** * 上传头像 **/ @Multipart @POST(\"uptUserHeadImg\") Call/*Observable*/&lt;UserBean&gt; uploadHead(@Part MultipartBody.Part photo, @Part(\"uid\") RequestBody userId); /** * 下载图片 */ @GET Call/*Observable*/&lt;ResponseBody&gt; downloadPicFromNet(@Url String fileUrl);&#125; *注释部分是配合Rx使用这里我们介绍一下retrofit的注解 get请求 @GET 申明get请求方式，括号里面是请求路径。 @Query 请求参数对应的键值，括号内为key，参数为value。 @QueryMap 如果Query参数比较多，那么可以通过@QueryMap方式将所有的参数集成在一个Map。 @Path 会把参数填充到路径上，如上面的@Path(&quot;year&quot;) @Path(&quot;month&quot;) @Path(&quot;day&quot;) 会填充@GET(&quot;day/{year}/{month}/{day}&quot;) 中的year、month、day。@Path可用于任何请求方式。 @Url 不使用baseUrl。 post请求 @POST 申明post请求方式，括号里面是请求路径。 @FormUrlEncoded 自动将请求参数的类型调整为application/x-www-form-urlencoded，FormUrlEncoded不能用于Get请求。 @Field 请求参数对应的键值。 @FieldMap 如果Field参数比较多，那么可以通过@FieldMap 方式将所有的参数集成在一个Map。 @Body 请求参数有多个，那么统一封装到类中应该会更好，这样维护起来会非常方便。 上传文件 @Multipart 申明为上传文件方式。 @Part 参数列表 MultipartBody.Part 为文件类型，RequestBody 为一般参数。 @PartMap 如果Part参数比较多，那么可以通过@PartMap 方式将所有的参数集成在一个Map。@PartMap Map&lt;String, RequestBody&gt; params 可以是多个文件，也可是文件与参数混合。 接口类写好后，我们要写个单例模式的网络请求类12345678910111213141516171819202122232425262728293031323334353637public class Api &#123; public static final String BASE_URL = \"http://gank.io/api/\"; public final static MediaType TYPE_IMAGE = MediaType.parse(\"image/*\"); public static final int DEFAULT_TIMEOUT = 30; public Retrofit retrofit; public ApiService service; //构造方法私有 private Api() &#123; OkHttpClient okHttpClient = new OkHttpClient.Builder() .readTimeout(DEFAULT_TIMEOUT, TimeUnit.SECONDS) .connectTimeout(DEFAULT_TIMEOUT, TimeUnit.SECONDS) .build(); Gson gson = new GsonBuilder().setDateFormat(\"yyyy-MM-dd'T'HH:mm:ssZ\").serializeNulls().create(); retrofit = new Retrofit.Builder() .client(okHttpClient) .addConverterFactory(GsonConverterFactory.create(gson)) //.addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .baseUrl(BASE_URL) .build(); service = retrofit.create(ApiService.class); &#125; //在访问HttpMethods时创建单例 private static class SingletonHolder &#123; private static final Api INSTANCE = new Api(); &#125; //获取单例 public static Api getInstance() &#123; return SingletonHolder.INSTANCE; &#125; 到这里基本上完成一大半，下面我们开始在Activity、fragment等中调用。12345678910111213141516171819202122232425262728293031323334353637383940414243Calendar calender = Calendar.getInstance();calender.setTime(date); //Rx使用方式Api.getInstance().service.getDayData(calender.get(Calendar.YEAR), calender.get(Calendar.MONTH) + 1, calender.get(Calendar.DAY_OF_MONTH)) .subscribeOn(Schedulers.io()) .map(new Func1&lt;GankData, GankData.ResultsBean&gt;() &#123; @Override public GankData.ResultsBean call(GankData gankData) &#123; return gankData.getResults(); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;GankData.ResultsBean&gt;() &#123; @Override public void onCompleted() &#123; Log.v(\"success:\", \"onCompleted\"); &#125; @Override public void onError(Throwable e) &#123; Log.v(\"failure:\", \"onError\"); &#125; @Override public void onNext(GankData.ResultsBean resultsBean) &#123; &#125; &#125;); //call使用方式Api.getInstance().service.getDayData(calender.get(Calendar.YEAR), calender.get(Calendar.MONTH) + 1, calender.get(Calendar.DAY_OF_MONTH)) .enqueue(new Callback&lt;GankData&gt;() &#123; @Override public void onResponse(Call&lt;GankData&gt; call,Response&lt;GankData&gt; response) &#123; &#125; @Override public void onFailure(Call&lt;GankData&gt; call, Throwable t) &#123; &#125;&#125;); 其他的接口也是类似的操作。 总结&#8195;&#8195; retrofit使用起来还是蛮方便的，其他还有header、日志、拦截器等的内容没有介绍，考虑到一般情况下是不需要对这些进行操作的 。使用retrofit后台必须遵循restful原则，具体概念可上网了解。例子中使用到了Rx等相关的知识，了解java后端的应该对链式操作有所了解，需要学习的小伙伴可参考抛物线的给 Android 开发者的 RxJava 详解 ，这篇文章对Rx进行了详细的解读。目前Rx 2.0的版本也已发布，相对1.0有些许改动。","tags":[{"name":"网络请求","slug":"网络请求","permalink":"//dongqing123.cn/tags/网络请求/"},{"name":"Android","slug":"Android","permalink":"//dongqing123.cn/tags/Android/"},{"name":"retrofit","slug":"retrofit","permalink":"//dongqing123.cn/tags/retrofit/"}]},{"title":"React Native 配置","date":"2017-01-04T03:22:26.000Z","path":"2017/01/04/React-Native-配置/","text":"&#8195;&#8195;近年来随着移动互联网的发展，移动可以说在飞速的进步，加上各种培训机构，市场上涌入了大堆大堆的新人加入到手机App的行业，从而形成了饱和的状态。从2016年初开始，移动开发出现了各种低潮，从找工作这一方面来看，明显难度高了好多，公司都不愿意招手机app的人员，反而愿意招收后端开发。明明年底是跳槽的一次进修，现在都开始观望了，不敢轻易，当然实力大牛这些对他们来说影响不大。不过最近出现了许多替代原生开发的工具，从早期的phoneGap,到比较火的H5，以及2015年出现RN，听说微信的“小程序”也想分一杯羹。各种原生已死的评论到处都是，作为手机开发人员当然知道这些目前还不太可能，但是也不能坐吃山空，墨守成规。对于这些新技术也是要了解一下的。&#8195;&#8195;React Native 目前也有一年多的历史了，应用商店也有许多基于RN的App，应该算是比较成熟了，但官方依然还是0.x.x的版本，正式版不知何时发布。 RN环境配置在RN中文网上有详细的搭建开发环境，一般按着步骤走是可行的，若安装较慢可以使用科学上网或者换淘宝的镜像。 ##搭建RN项目环境搭建完成后，是时候开始学习RN了，我们先从新建项目开始，官方是通过123react-native init AwesomeProjectcd AwesomeProjectreact-native run-android 命令来实现项目的新建与运行（部分手机会crash需要到权限管理中心开启悬浮窗权限），也可参考江清清的博客React Native专题中的两篇React Native For Android环境配置以及第一个实例、React Native移植原生Android项目-已更新版本-New。如果你已新建项目并且Android没有修改代码可以通过以下操作12adb reverse tcp:8081 tcp:8081react-native start 上面命令来启动服务，手机打开RN项目通过重新加载JS就可以了（摇一摇或者按menu菜单键选择Reload）。 编辑JSRN相比原生最方便的就是修改代码（不涉及原生代码）不需要重新安装，只需要重新加载JS就可以了，非常的方便。而且大部分JS代码Android与iOS是可以共用的，可以说是实现了一套代码两个版本。编辑JS的IDE可供选择的有很多，atom、webstorm、sublime text3等等，可根据个人习惯选择。 最后本篇主要说的是RN的环境配置与搭建RN项目，平时在业余时间可以用来练练手，学习学习。但是用于商业项目还是需要相当谨慎的，也许会遇到很多很多的填不完的坑。","tags":[{"name":"Android","slug":"Android","permalink":"//dongqing123.cn/tags/Android/"},{"name":"RN","slug":"RN","permalink":"//dongqing123.cn/tags/RN/"}]},{"title":"OkHttp的使用","date":"2017-01-04T03:20:51.000Z","path":"2017/01/04/OkHttp的使用/","text":"网络请求框架我一直都使用httpclient，后来改成了xutils，但是去年开始自从Android6.0去掉了httpclient的支持，想要使用还要在build.gradle添加useLibrary &#39;org.apache.http.legacy&#39;，加上google的推广，Okhttp变得非常火了起来，于是自己也修改自己的网络框架。我使用时OkHttp已经出现3.0的版本了，与2.0的版本还是有一些差别的 get基本上没有什么区别 2.0123456OkHttpClient client = new OkHttpClient();client.setConnectTimeout(15,TimeUnit.SECONDS);client.setWriteTimeout(20,TimeUnit.SECONDS); client.setReadTimeout(20,TimeUnit.SECONDS);Request request = new Request.Builder().url(url).build();Response response = client.newCall(request).execute(); 3.0123456OkHttpClient client = new OkHttpClient();client.newBuilder().connectTitmeout(15,TimeUnit.SECONDS)client.newBuilder().readTimeout(15,TimeUnit.SECONDS)client.newBuilder().wirteTimeout(15,TimeUnit.SECONDS)Request request = new Request.Builder().url(url).build();Response response = client.newCall(request).execute(); post取消了FormEncodingBuilder使用FormBody 2.01234OkHttpClient client = new OkHttpClient();RequestBody requestBody = new FormEncodingBuilder() .add(\"\",\"\").add(\"\",\"\").build();Request request = new Request.Builder().url(url).post(requestBody).build();Response response = client.newCall(request).execute(); 3.01234OkHttpClient client = new OkHttpClient();RequestBody requestBody = new FormBody.Builder().add(\"\",\"\").add(\"\",\"\").build();Request request = new Request.Builder().url(url).post(requestBody).build();Response response = client.newCall(request).execute(); 上传文件MultipartBuilder改为MultipartBody 2.0123456789OkHttpClient client = new OkHttpClient();MultipartBuilder multipartEntity = new MultipartBuilder().type(MultipartBuilder.FORM); File file = new File(tmepName);RequestBody fileBody = RequestBody.create(MediaType.parse(\"image/*\"), file);multipartEntity.addFormDataPart(key,file.getName(), fileBody);multipartEntity.addFormDataPart(key, value);RequestBody requestBody = multipartEntity.build();Request request = new Request.Builder().url(url).post(requestBody).build();Response response = client.newCall(request).execute(); 3.0123456789OkHttpClient client = new OkHttpClient();MultipartBody.Builder multipartEntity = new MultipartBody.Builder();File file = new File(tmepName);RequestBody fileBody = RequestBody.create(MediaType.parse(\"image/*\"), file);multipartEntity.addFormDataPart(key,file.getName(), fileBody);multipartEntity.addFormDataPart(key, value);RequestBody requestBody = multipartEntity.build();Request request = new Request.Builder().url(url).post(requestBody).build();Response response = client.newCall(request).execute(); cookie使用cookieJar替代cookieHandler持久化文件 2.01client.setCookieHandler(new CokieManager(new PersistentCookieStore(context), CookiePolicy.ACCEPT_ALL)); 3.01client.newBuilder().cookieJar(new CookiesManager()); 以上就是OkHttp的简单使用以及2.0与3.0的差异，下一篇我们讲解retrofit。","tags":[{"name":"网络请求","slug":"网络请求","permalink":"//dongqing123.cn/tags/网络请求/"},{"name":"okHttp","slug":"okHttp","permalink":"//dongqing123.cn/tags/okHttp/"},{"name":"Android","slug":"Android","permalink":"//dongqing123.cn/tags/Android/"}]},{"title":"2016年总结","date":"2016-12-31T03:21:33.000Z","path":"2016/12/31/2016年总结/","text":"&#8195;&#8195;时间总是过的飞快，转眼之间2016年已经没剩几天了，想想自己都是26岁的人了，离自己的梦想也渐行渐远。&#8195;&#8195;回顾这一整年，发现自己干的琐事确实蛮多的，但坚持的事总是没有，想想自己都快毕业3年了，还是碌碌无为呀。反而看了许多人写的年终总结，发现自己与他们的差距真的是非常的大，人家一年做了好多好多的实事，而我一年都不知道干了什么。&#8195;&#8195;说实话我是不喜欢写总结来着，这算是我第一次。想想自己都出来3年了，考研的现在也该毕业了，自己的年龄也是越来越大，精力也不想以前那么充沛了，实在不想再浑浑噩噩的过日子。&#8195;&#8195;废话说了这么多，看看我16年都干了些什么。&#8195;&#8195;想了想实在不知道干么了。。。&#8195;&#8195;3月份当时点窝业务还在，还在维护点窝商城与电视TV，还有就是我的手下离职了，我成了孤家寡人，之后就开始做电子券与供销通的业务。&#8195;&#8195;说起来就觉得公司比较坑，app做了一版又一版就是没有投入使用，给我的感觉就是我做的app一个都没上线。之后我就开始投入到万千同性交友网站github的怀抱，写demo。&#8195;&#8195;好了基本上就这些，然后就是学习。&#8195;&#8195;学习drag2、mvp 、rx、okhttp、retrofit等等开源框架，订阅与关注了许多大牛，了解RN、热修复等等相关的知识，写写演示Demo。&#8195;&#8195;到12月份的时候，我终于打算写个人app上线应用商店。我开始基于gank.io写我的个人app，注册了三大平台的账号，前前后后花了大概3周的时间终于上线了，但也仅仅是上线了。&#8195;&#8195;写完我是真发现没做什么实事呢。&#8195;&#8195;2017年真是希望自己有所改变，不管是技术还是人际。","tags":[{"name":"总结","slug":"总结","permalink":"//dongqing123.cn/tags/总结/"},{"name":"随笔","slug":"随笔","permalink":"//dongqing123.cn/tags/随笔/"}]},{"title":"Hello World","date":"2016-12-28T06:16:40.000Z","path":"2016/12/28/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]